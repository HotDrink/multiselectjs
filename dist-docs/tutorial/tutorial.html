<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>MultiselectJS Tutorial</title>
<!-- 2015-09-08 Tue 00:19 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Jaakko JÃ¤rvi" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<style>body { font-family: Arial, Verdana, Helvetica, sans-serif; }</style>
<style>.org-src-name { font-weight: normal; text-decoration: overline underline;  font-family: monospace; margin-top: 1cm; }</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">MultiselectJS Tutorial</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a>
<ul>
<li><a href="#sec-1-1">1.1. Concepts</a></li>
<li><a href="#sec-1-2">1.2. The meaning of click, command-click, and shift-click</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Example: selecting from an ordered list of non-overlapping elements</a>
<ul>
<li><a href="#sec-2-1">2.1. Imports</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1. <code>multiselect.js</code> as a module</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. Selectable elements</a></li>
<li><a href="#sec-2-3">2.3. Visualizing the selection state</a></li>
<li><a href="#sec-2-4">2.4. Selection geometry</a></li>
<li><a href="#sec-2-5">2.5. Selection state object</a></li>
<li><a href="#sec-2-6">2.6. Setting up mouse events</a></li>
<li><a href="#sec-show-selected">2.7. Accessing selected elements</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Example: selection geometry that is both row-wise ordered and rectangular</a>
<ul>
<li><a href="#sec-3-1">3.1. Selectable elements</a></li>
<li><a href="#sec-refreshing-and-tracking">3.2. Refreshing</a></li>
<li><a href="#sec-3-3">3.3. Selection geometry</a></li>
<li><a href="#sec-create-selection-state-2">3.4. Selection state object</a></li>
<li><a href="#sec-3-5">3.5. Mouse events</a></li>
<li><a href="#sec-3-6">3.6. Keyboard events</a></li>
<li><a href="#sec-path-visualization">3.7. Visualizing anchor, cursor, and rubber band</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Example: snake selection geometry</a>
<ul>
<li><a href="#sec-4-1">4.1. Selectable elements</a></li>
<li><a href="#sec-4-2">4.2. Selection geometry</a></li>
<li><a href="#sec-4-3">4.3. Constructing the selection state object</a></li>
<li><a href="#sec-4-4">4.4. Visualizing anchor, cursor, and rubber band</a></li>
<li><a href="#sec-4-5">4.5. Setting up mouse events</a></li>
<li><a href="#sec-line-intersection-code">4.6. Line intersection code</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
MultiselectJS is a library for implementing <i>multi-selection</i>, that is, the
feature supporting selecting and deselecting elements from a
collection using the mouse (or another pointing device) or a
keyboard. The visual aspects of selection, the shape and location of
elements, their ordering, indicators of selection status, etc. vary
from one application to another. These are the aspects that the client
defines, MultiselectJS implements the rest.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Concepts</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The multi-selection task is to identify a subset of a
collection of elements.  To abstract over what these elements are (DOM
elements, characters in text, polygons drawn on a canvas, and so forth), we
assume that each element is uniquely identified by some
<i>index</i>. Indices can be of any type that can be compared for equality
with <code>===</code>, such as numbers, object references, or strings.
</p>

<p>
The selection state of elements is modeled as a mapping from indices
to booleans, where <code>true</code> indicates that an element is selected,
<code>false</code> that it is not.  We call such a mapping a <i>selection
mapping</i>.  User&rsquo;s selection actions, such as clicking the mouse on an
element, dragging a ``rubber band&rsquo;&rsquo; around elements, or pressing an
arrow key with the shift modifier key held down translate to one or
more <i>selection operations</i> that modify the selection mapping.
</p>

<p>
Each selection operation is associated with a <i>selection domain</i> that
determines the set of indices that the operation affects, and a
<i>selection function</i> that determines whether the indices will be
selected, deselected, or toggled.  The user indicates the selection
domain through specifying a <i>selection path</i>, a sequence of points in
some suitable coordinate space. This <i>selection space</i> could be, for
example, the mouse locations in a window or pairs of row and column
indices in a grid of elements.  The first point of a selection path
arises from a click or a command-click<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> and the subsequent points
from shift-clicks (or mouse moves, when rubber band selecting).  The
first point is called the <i>anchor</i> and the last the <i>active end</i> of
the path. In the case of a one-element path, the active end coincides
with the anchor. The selection domain specified by the current selection path
is the <i>active</i> selection domain.
</p>

<p>
Figure <a href="#fig-selection-concepts-results">1</a> shows concrete instances of the
above concepts. The selectable elements are rectangles of arbitrary
size, they are placed in arbitrary locations, and they can overlap. We
make the following observations:
</p>

<ul class="org-ul">
<li>The selected elements are items 2, 4, 5, and 6, and hence the
selection mapping maps the indices 2, 4, 5, and 6 to <code>true</code>, and all
other indices to <code>false</code>.</li>
<li>The element 4 has been selected with a prior selection command.
To select the elements 2, 5, and 6, the user has clicked the
location marked with a red circle, and then dragged the mouse
(<i>rubber band selection</i>) through several other locations (small
blue dots). The last, and current, mouse location is marked with
a blue circle.</li>
<li>The selection space is the space of mouse coordinates.
The sequence of points indicated by the blue dots therefore
constitute the selection path.</li>
<li>In most selection contexts, the anchor and active end are the only
points that matter in determining the selection domain. Here, the
anchor and active end serve as the opposite corners of a
rectangle&#x2014;all elements that overlap with this rectangle (shown
in blue) belong to the active selection domain.</li>
</ul>


<div id="fig-selection-concepts-results" class="figure">
<p><img src="selection_concepts.png" alt="selection_concepts.png" />
</p>
<p><span class="figure-number">Figure 1:</span> A snapshot of multi-selection interaction. The selection path (the blue points) gives rise to the selection domain consisting of the items 2, 5 and 6.</p>
</div>

<p>
How the selection path determines the selection domain varies from one
context to another. This variation is captured by the <i>selection
geometry</i>.  Concretely, a selection geometry in MultiselectJS is an
object that defines the functions:
</p>

<ul class="org-ul">
<li><code>m2v(point)</code> that converts mouse coordinates to selection space
coordinates;</li>
<li><code>selectionDomain(path, cmdType, J)</code> that maps a selection <code>path</code>
to a selection domain (the <code>cmdType</code> and <code>J</code> parameters are to
enable optimizations, and they are explained later);</li>
<li><code>extendPath(path, point)</code> that defines how a new point is added to
the selection path;</li>
<li><code>filter(pred)</code> that computes a selection domain as the set of
indices that satisfy the predicate <code>pred</code>;</li>
<li><code>step(direction, point)</code> that defines how arrow keys should impact
the current <i>keyboard cursor</i> location; and</li>
<li><code>defaultCursor(direction)</code> that defines default cursor locations
for when keyboard cursor has not yet been established.</li>
</ul>

<p>
The library has default definitions for each of the selection
geometry&rsquo;s functions, and often it suffices to implement only a subset
of them. For example, in the selection geometry of Figure
<a href="#fig-selection-concepts-results">1</a>, the default definitions for <code>m2v</code>
(identity function) and <code>extendPath</code> (add point as the new anchor) can
be used.  If the example does not support keyboard selection, <code>step</code>
and <code>defaultCursor</code> need not be defined.  If it does not support
selection by a predicate, <code>filter</code> need not be defined.  The only
function that must be defined is <code>selectionDomain</code>; it computes the
indices of the elements that overlap with the rectangle indicated by
the anchor and active end.
</p>


<div id="fig-simple-selection-geometry-results" class="figure">
<p><img src="simple-selection-geometry.png" alt="simple-selection-geometry.png" />
</p>
<p><span class="figure-number">Figure 2:</span> The selection path is the sequence 5, 2. The anchor is 5 and the active end 2. The selection domain is the set {2, 3, 4, 5}.</p>
</div>

<p>
Figure <a href="#fig-simple-selection-geometry-results">2</a> shows a snapshot from a
selection context that has a different selection geometry.  In this
geometry the selection space coincides with the set of element
indices: the <code>m2v</code> function maps all mouse positions that fall within
an element&rsquo;s extents to the index of that element.  In this context,
elements are considered to be ordered, so the <code>selectionDomain</code>
function maps a selection path to the range of indices between
(inclusive) the path&rsquo;s anchor and active end. The anchor is marked
with a red dashed frame and the active end with blue.  Here, the user
has clicked first somewhere on <code>Item 5</code> and then shift-clicked
somewhere on <code>Item 2</code>.  As a result, all elements between these two
items are marked selected.
</p>


<p>
Another aspect that varies from one selection context to another is if
and how the anchor and the active end, and more generally the
selection path, are visualized.  MultiselectJS leaves these questions to
the client, but makes the data needed for those visualizations readily
available (see Section <a href="#sec-path-visualization">3.7</a>).
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> The meaning of click, command-click, and shift-click</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<i>Click</i>, <i>command-click</i>, and <i>shift-click</i> are the basic selection
tools that most applications support. Different applications assign
slightly different meanings to these operations. The key bindings may
vary as well (e.g., Windows&rsquo; <i>ctrl-click</i> corresponds to OS X&rsquo;s
command-click).  These three commands are the basic building blocks of
MultiselectJS, in terms of which most other (keyboard and rubber band
selection) commands are defined.  In a nutshell, the three selection
commands work as follows:
</p>

<ul class="org-ul">
<li>Click deselects all selected elements. The clicked point becomes the
anchor and the sole element of the selection path.  The new active
selection domain is computed from this selection path; the elements
in this domain are selected.  The selection function is set to
<i>select</i>, so that subsequent shift-click operations will select,
rather than deselect, elements.</li>

<li>The clicked point becomes the anchor and the sole element of the
selection path.  The new active selection domain is computed from
this selection path.  If the anchor is on an already selected
element, the selection function is set to <i>deselect</i>, otherwise to
<i>select</i>.  The elements of the active selection domain are either
selected or deselected according to the selection function.</li>

<li>Shift-click extends the current selection path with a new point. It
computes a new selection domain that corresponds to this selection
path. The new selection domain replaces the current active selection
domain.</li>
</ul>

<p>
MultiselectJS does not insist on particular key bindings for any of the
selection operations, but the naming of the functions in its public
API reflects our recommendations.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Example: selecting from an ordered list of non-overlapping elements</h2>
<div class="outline-text-2" id="text-2">
<p>
The first example is a horizontal list of elements, in which elements
can be selected using the click, command-click, and shift-click
commands.  The <i>Show animals</i> button displays a list of currently
selected elements.
</p>

<script type="text/javascript" src="../../dist/multiselect.js"></script>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <style>
    .selectable { outline:1px solid; padding:10px; cursor:default; }
    .selected { background-color: khaki; }
  </style>
<script type="text/javascript">
     // helper functions to deal with points, rectangles, etc.
       function pointInRectangle(mp, r) {
         return mp.x >= r.left && mp.x <= r.right && 
                mp.y >= r.top  && mp.y <= r.bottom;
       }
   
     // OrderedList selection geometry
     var OrderedGeometry = function (elements) {
       this._elements = elements;
     }
     OrderedGeometry.prototype = Object.create(multiselect.DefaultGeometry.prototype);
       OrderedGeometry.prototype.m2v = function(mp) {
         for (var i=0; i<this._elements.length; ++i) {
           if (pointInRectangle(mp, this._elements[i].getBoundingClientRect())) return i;
         }
       }
       OrderedGeometry.prototype.selectionDomain = function(path) {
         var J = multiselect.makeEmptyMap();
         var a = multiselect.anchor(path);
         var b = multiselect.activeEnd(path);
         for (var i=Math.min(a, b); i<=Math.max(a, b); ++i) J.set(i, true);
         return J;
       }

   document.addEventListener("DOMContentLoaded", function() { 

      // selectable elements
      var selectableArea = document.getElementById("selectable_area");
      var selectables = selectableArea.getElementsByClassName("selectable");
      
      // the refresh function
        function refresh(s) {
          for(var i=0; i<selectables.length; ++i) { 
            selectables[i].classList.toggle('selected', s(i));
          };
        }  
      
      // create the selection object
        var geometry = new OrderedGeometry(selectables);
        var selection = new multiselect.SelectionState(geometry, refresh, false, 10);
      
      // register mouse events
        function mousedownHandler(evt) {
          evt.preventDefault();
          evt.stopPropagation();
      
          var vp = selection.geometry().m2v({ x: evt.clientX, y: evt.clientY });
      
          switch (multiselect.modifierKeys(evt)) {
          case multiselect.NONE: selection.click(vp); break;
          case multiselect.CMD: selection.cmdClick(vp); break;
          case multiselect.SHIFT: selection.shiftClick(vp); break;
          }
        };
      
        selectableArea.addEventListener('mousedown', mousedownHandler, false);
      
      // find out which elements are selected
        function showAnimals() {
          var s = "";
          selection.selected().forEach(function(v) { 
            s = s + selectables[v].textContent + " "; 
          });
          document.getElementById("animal_list").textContent = s; 
        }
        document.getElementById("show_animals").addEventListener("click", showAnimals);

   });
</script>
    <table id="selectable_area">
      <tr><td class="selectable">pig</td>
      <td class="selectable">cow</td>             
      <td class="selectable">goat</td>
      <td class="selectable">horse</td>
      <td class="selectable">sheep</td>
      <td class="selectable">chicken</td>
      <td class="selectable">duck</td>
      <td class="selectable">turkey</td>
      <td class="selectable">ostrich</td>
      <td class="selectable">mule</td>
      </tr>
    </table>

    <br>
    <button id="show_animals">Show selected animals</button> <span id="animal_list"></span>

<p target="_blank">
The <a href="example-1.html" target="_blank">example</a> and its 
<a href="javascript:viewSource('example-1.html')">
complete source code</a> can be viewed in separate windows.
</p>

<script>
function viewSource(file) {
  var str = window.location.href;
  window.open("view-source:" + str.substring(0, str.lastIndexOf("/")) + "/"+file);
}
</script>

<p>
The implementation of this example consists of the following:
</p>

<ol class="org-ol">
<li>Importing the MultiselectJS library.</li>
<li>Defining the selectable elements.</li>
<li>Defining a <i>refresh</i> function that visualizes the selection state of the elements.</li>
<li>Defining a selection geometry object.</li>
<li>Constructing a <code>SelectionState</code> object that maintains all of the selection state.</li>
<li>Defining mouse event handlers to call appropriate functions of <code>SelectionState</code>.</li>
</ol>

<p>
We explain each of the steps below.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Imports</h3>
<div class="outline-text-3" id="text-2-1">
<p>
To use MultiselectJS on a page is a matter of importing it as a script. 
There are no dependencies; we import <i>jQuery</i> because we use it in this tutorial.
</p>

<div class="org-src-container">

<pre class="src src-html" id="js-imports">&lt;<span style="color: #006699;">script</span> <span style="color: #BA36A5;">type</span>=<span style="color: #008000;">"text/javascript"</span> <span style="color: #BA36A5;">src</span>=<span style="color: #008000;">"../../dist/multiselect.js"</span>&gt;&lt;/<span style="color: #006699;">script</span>&gt;
&lt;<span style="color: #006699;">script</span> <span style="color: #BA36A5;">type</span>=<span style="color: #008000;">"text/javascript"</span> <span style="color: #BA36A5;">src</span>=<span style="color: #008000;">"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"</span>&gt;&lt;/<span style="color: #006699;">script</span>&gt;
</pre>
</div>
</div>

<div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> <code>multiselect.js</code> as a module</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Alternatively, <code>multiselect.js</code> is provided as a (CommonJS) module.
It can be installed locally as so:
</p>

<div class="org-src-container">

<pre class="src src-sh">npm install git+https://github.com/hotdrink/multiselectjs.git
</pre>
</div>

<p>
and then used in a project like this:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">multiselect</span> = require(<span style="color: #008000;">"multiselect"</span>);
</pre>
</div>

<p>
Note that MultiselectJS uses ES6 features. 
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Selectable elements</h3>
<div class="outline-text-3" id="text-2-2">
<p>
In this example, the selectable elements are HTML table cells.  We
give the cells the <code>selectable</code> class attribute so that they are
easily accessible. The <code>animal_list</code> span is a placeholder for where
the selected animal names will be shown when the <code>show_animals</code> button
is clicked.
</p>

<div class="org-src-container">

<pre class="src src-html" id="ordered-list-html">    &lt;<span style="color: #006699;">table</span> <span style="color: #BA36A5;">id</span>=<span style="color: #008000;">"selectable_area"</span>&gt;
      &lt;<span style="color: #006699;">tr</span>&gt;&lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;pig&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;cow&lt;/<span style="color: #006699;">td</span>&gt;             
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;goat&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;horse&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;sheep&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;chicken&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;duck&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;turkey&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;ostrich&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;mule&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;/<span style="color: #006699;">tr</span>&gt;
    &lt;/<span style="color: #006699;">table</span>&gt;

    &lt;<span style="color: #006699;">br</span>&gt;
    &lt;<span style="color: #006699;">button</span> <span style="color: #BA36A5;">id</span>=<span style="color: #008000;">"show_animals"</span>&gt;Show selected animals&lt;/<span style="color: #006699;">button</span>&gt; &lt;<span style="color: #006699;">span</span> <span style="color: #BA36A5;">id</span>=<span style="color: #008000;">"animal_list"</span>&gt;&lt;/<span style="color: #006699;">span</span>&gt;
</pre>
</div>

<p>
Next, we access the above HTML elements from JavaScript code:
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-list-selectables"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectableArea</span> = document.getElementById(<span style="color: #008000;">"selectable_area"</span>);
<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectables</span> = selectableArea.getElementsByClassName(<span style="color: #008000;">"selectable"</span>);
</pre>
</div>

<p>
The <code>selectableArea</code> object is the target of the mouse events.
The <code>selectables</code> objects is the collection of the selectable elements;
it is an &ldquo;array-like&rdquo; object, indexed with integers.
</p>
</div>
</div>


<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Visualizing the selection state</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The following CSS code defines the visual appearance of selectable
elements in both their unselected and selected states.
The <code>.selected</code> class is turned on when an element is selected and off
when deselected.
</p>

<div class="org-src-container">

<pre class="src src-html" id="ordered-list-css">  &lt;<span style="color: #006699;">style</span>&gt;
    .selectable { outline:1px solid; padding:10px; cursor:default; }
    .selected { background-color: khaki; }
  &lt;/<span style="color: #006699;">style</span>&gt;
</pre>
</div>

<p>
To display the current selection state, MultiselectJS invokes a
callback function after every selection command (unless the library
recognizes that a command had no effect), passing it the current selection mapping.  
We use the <code>refresh(s)</code> function below as the callback; it iterates
over all selectable elements and toggles the <code>selected</code> class
attribute according to each element&rsquo;s selection status:
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-list-refresh">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">refresh</span>(<span style="color: #BA36A5;">s</span>) {
    <span style="color: #0000FF;">for</span>(<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=0; i&lt;selectables.length; ++i) { 
      selectables[i].classList.toggle(<span style="color: #008000;">'selected'</span>, s(i));
    };
  }
</pre>
</div>

<p>
The library can also be configured to <i>track changes</i>, in which case
the argument to the callback would be a <code>Map</code><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> of changed
elements. This mechanism is explained in Section
<a href="#sec-refreshing-and-tracking">3.2</a>.
</p>
</div>
</div>


<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Selection geometry</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The <code>OrderedGeometry</code> class<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup> defines the selection geometry for our example.
The <code>_elements</code> member is a reference to the collection of the selectable elements.
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-geometry"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">OrderedGeometry</span> = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">elements</span>) {
  <span style="color: #8b1a1a;">this</span>._elements = elements;
}
OrderedGeometry.<span style="color: #8b1a1a;">prototype</span> = Object.create(multiselect.DefaultGeometry.<span style="color: #8b1a1a;">prototype</span>);
</pre>
</div>

<p>
<code>OrderedGeometry</code> inherits from <code>DefaultGeometry</code> to get the default
implementations of the selection geometry methods.  The superclass&rsquo;
constructor is not called since the base class has no
state. <code>OrderedGeometry</code> defines two methods: <code>m2v</code> and
<code>selectionDomain</code>.
</p>

<p>
The selection space coordinates are the indices of the selectable
elements, integers between <code>0</code> and <code>this._elements.length - 1</code>.  
The <code>m2v</code> function finds the element on which the
mouse coordinate <code>mp</code> falls on and returns the element&rsquo;s index.
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-geometry-m2v">  OrderedGeometry.<span style="color: #8b1a1a;">prototype</span>.m2v = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">mp</span>) {
    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=0; i&lt;<span style="color: #8b1a1a;">this</span>._elements.length; ++i) {
      <span style="color: #0000FF;">if</span> (pointInRectangle(mp, <span style="color: #8b1a1a;">this</span>._elements[i].getBoundingClientRect())) <span style="color: #0000FF;">return</span> i;
    }
  }
</pre>
</div>

<p>
The helper function <code>pointInRectangle</code> checks whether a point is
inside a rectangle. 
</p>

<div class="org-src-container">

<pre class="src src-js" id="point-in-rectangle">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">pointInRectangle</span>(<span style="color: #BA36A5;">mp</span>, <span style="color: #BA36A5;">r</span>) {
    <span style="color: #0000FF;">return</span> mp.x &gt;= r.left &amp;&amp; mp.x &lt;= r.right &amp;&amp; 
           mp.y &gt;= r.top  &amp;&amp; mp.y &lt;= r.bottom;
  }
</pre>
</div>

<p>
The <code>selectionDomain</code> function is simple&#x2014;it constructs a new <code>Map</code>
object with <code>makeEmptyMap</code>, extracts the anchor and active end
from the selection path, and sets all indices between them to <code>true</code>:
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-geometry-selection-domain">  OrderedGeometry.<span style="color: #8b1a1a;">prototype</span>.selectionDomain = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">path</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">J</span> = multiselect.makeEmptyMap();
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">a</span> = multiselect.anchor(path);
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">b</span> = multiselect.activeEnd(path);
    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=Math.min(a, b); i&lt;=Math.max(a, b); ++i) J.set(i, <span style="color: #8b1a1a;">true</span>);
    <span style="color: #0000FF;">return</span> J;
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Selection state object</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The <code>SelectionState</code> class maintains all the state of the selection,
including the current selection mapping, selection path, and undo and
redo stacks.  It defines methods for the various selection commands
(<code>click</code>, <code>cmdClick</code>, <code>shiftClick</code>, etc.).  The <code>SelectionState</code>
constructor&rsquo;s parameters are a <i>selection geometry</i>, the <i>refresh callback</i>, a
boolean that turns <i>change tracking</i> on or off, and the <i>maximum number
of undo states</i>. The last two can be omitted if their defaults
(<code>false</code> and <code>10</code>, respectively) are suitable.
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-list-create-selection">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">geometry</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">OrderedGeometry</span>(selectables);
  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selection</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">multiselect.SelectionState</span>(geometry, refresh, <span style="color: #8b1a1a;">false</span>, 10);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> Setting up mouse events</h3>
<div class="outline-text-3" id="text-2-6">
<p>
The event handler for the <i>mouse down</i> event recognizes clicks,
command-clicks, and shift-clicks, and invokes the corresponding
library functions. Detecting modifier keys is somewhat messy.
MultiselectJS provides a function <code>modifierKeys(evt)</code> that translates
the event data to constants that indicate shift, command/ctrl, and
option/alt  modifiers. These constants are
<code>NONE</code>, <code>SHIFT</code>, <code>CMD</code>, <code>SHIFT_CMD</code>, <code>OPT</code>, and <code>SHIFT_OPT</code>.
The client can certainly define its own functions to distinguish
between different mouse events if the one provided is not
adequate.
</p>

<p>
In this simple example, it suffices to 
define and register a handler for the <i>mousedown</i> event:
</p>

<div class="org-src-container">

<pre class="src src-js" id="setup-mouse-events-simple">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">mousedownHandler</span>(<span style="color: #BA36A5;">evt</span>) {
    evt.preventDefault();
    evt.stopPropagation();

    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">vp</span> = selection.geometry().m2v({ x: evt.clientX, y: evt.clientY });

    <span style="color: #0000FF;">switch</span> (multiselect.modifierKeys(evt)) {
    <span style="color: #0000FF;">case</span> multiselect.NONE: selection.click(vp); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.CMD: selection.cmdClick(vp); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.SHIFT: selection.shiftClick(vp); <span style="color: #0000FF;">break</span>;
    }
  };

  selectableArea.addEventListener(<span style="color: #008000;">'mousedown'</span>, mousedownHandler, <span style="color: #8b1a1a;">false</span>);
</pre>
</div>

<p>
We draw attention to the simplicity of invoking MultiselectJS&rsquo;s services: the
selection geometry&rsquo;s <code>m2v</code> function transforms the mouse position into
a selection space coordinate, which is then passed to either the <code>click</code>,
<code>cmdClick</code>, or <code>shiftClick</code> method.
</p>
</div>
</div>

<div id="outline-container-sec-show-selected" class="outline-3">
<h3 id="sec-show-selected"><a id="sec-2-7"></a><span class="section-number-3">2.7</span> Accessing selected elements</h3>
<div class="outline-text-3" id="text-sec-show-selected">
<p>
The first example is complete except for the handler for the ``Show selected animals&rsquo;&rsquo; button
that displays a list of the selected elements. 
The <code>selection.selected()</code> call returns the indices of the selected elements as a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>.
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-list-show-animals">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">showAnimals</span>() {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">s</span> = <span style="color: #008000;">""</span>;
    selection.selected().forEach(<span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">v</span>) { 
      s = s + selectables[v].textContent + <span style="color: #008000;">" "</span>; 
    });
    document.getElementById(<span style="color: #008000;">"animal_list"</span>).textContent = s; 
  }
  document.getElementById(<span style="color: #008000;">"show_animals"</span>).addEventListener(<span style="color: #008000;">"click"</span>, showAnimals);
</pre>
</div>

<p>
Another means to inspect the current selection state, not used here,
is the <code>isSelected(i)</code> method that returns <code>true</code> if the element <code>i</code> is
selected and <code>false</code> otherwise.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Example: selection geometry that is both row-wise ordered and rectangular</h2>
<div class="outline-text-2" id="text-3">
<script type="text/javascript">
    function rectangleIntersect(r1, r2) {
      return r1.left <= r2.right  && r1.right  >= r2.left && 
             r1.top  <= r2.bottom && r1.bottom >= r2.top;
    }
  
    function centerPoint (r) { return { x: (r.left + r.right)/2, 
                                        y: (r.top + r.bottom)/2 }; }
  
    function distance (p1, p2) {
      var dx = p1.x - p2.x;
      var dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  
    function isAbove(r1, r2) { return centerPoint(r2).y < r1.top; }
  
    function findClosestP(parent, elements, j, pred) {
      var r = getOffsetRectangle(parent, elements[j]);
      var candidateIndex = null; 
      var candidateDistance = Number.MAX_VALUE;
  
      for (var i=0; i<elements.length; ++i) {
        var rc = getOffsetRectangle(parent, elements[i]);
        if (pred(r, rc) && distance(centerPoint(r), centerPoint(rc)) < candidateDistance) {
          candidateIndex = i; 
          candidateDistance = distance(centerPoint(r), centerPoint(rc));
        }
      }
      if (candidateIndex === null) return j; else return candidateIndex;
    }
  
    function topLeftCorner(r) { return { x: r.left, y: r.top }; }
      
    function offsetRectangle(p, r) {
      return {
        left: r.left - p.x, top: r.top - p.y, 
        right: r.right - p.x, bottom: r.bottom - p.y 
      };
    }
  
    function getOffsetRectangle(parent, elem) {
      return offsetRectangle(topLeftCorner(parent.getBoundingClientRect()),
                             elem.getBoundingClientRect());
    }
  
    function offsetMousePos(parent, evt) { 
      var p = topLeftCorner(parent.getClientRects()[0]);
      return { x: evt.clientX - p.x, y: evt.clientY - p.y }; 
    }
  
  // canvas that tracks the size of parent
  function createCanvas (parent) {
  
    var canvas = document.createElement("canvas");
    canvas.style.position = 'absolute';
    parent.insertBefore(canvas, parent.firstChild);
  
    $(window).resize(resizeCanvas); 
    resizeCanvas();
  
    return canvas;
  
    function resizeCanvas() {
      var rect = parent.getBoundingClientRect();
      canvas.width = rect.right - rect.left;
      canvas.height = rect.bottom - rect.top;    
    }
  }
  
  // refresh callback
  function mkRefresh (elements, cls) {
    return (function (changed) {
      changed.forEach(function (value, i) { 
        $(elements[i]).toggleClass(cls, value); 
      });
    });
  }
  
  // row-wise geometry
  var RowwiseGeometry = function (parent, elements) {
    this._parent = parent;
    this._elements = elements;
  }
  RowwiseGeometry.prototype = Object.create(multiselect.DefaultGeometry.prototype);
  
    RowwiseGeometry.prototype.m2v = function(mp) {
      for (var i=0; i<this._elements.length; ++i) {
        var r = getOffsetRectangle(this._parent, this._elements[i]);
        if (pointInRectangle(mp, r)) return { index: i, point: mp };        
      }
      return { index: null, point: mp };
    }
  
    RowwiseGeometry.prototype.extendPath = function(path, p) {
      if (path.length > 0 &&
          multiselect.anchor(path).index !== null && p.index === null) return null;
      if (path.length == 2) path.pop();
      path.push(p); 
    }
  
    RowwiseGeometry.prototype.selectionDomain = function(path) {
      var J = multiselect.makeEmptyMap();
      var a = multiselect.anchor(path);
      var b = multiselect.activeEnd(path);
  
      if (a.index !== null) { // path defines a range
        for (var i=Math.min(a.index, b.index); i<=Math.max(a.index, b.index); ++i) 
          J.set(i, true);
      } else {                // path defines a rectangle
        var r1 = { left:   Math.min(a.point.x, b.point.x),
                   right:  Math.max(a.point.x, b.point.x),
                   top:    Math.min(a.point.y, b.point.y),
                   bottom: Math.max(a.point.y, b.point.y) };
        for (var i = 0; i < this._elements.length; ++i) {
          var r2 = getOffsetRectangle(this._parent, this._elements[i]);
          if (rectangleIntersect(r1, r2)) J.set(i, true);
        }
      }
  
      return J;
    }
  
    RowwiseGeometry.prototype.step = function (dir, p) {
      if (p.index === null) return p; // p is an "in-between" point, no change
      var ind = null;
      switch (dir) {
      case multiselect.LEFT:  ind = Math.max(p.index - 1, 0); break;
      case multiselect.RIGHT: ind = Math.min(p.index + 1, this._elements.length-1); break;
      case multiselect.UP: 
        ind = findClosestP.call(this, this._parent, this._elements, p.index, isAbove); 
        break;
      case multiselect.DOWN: 
        ind = findClosestP.call(this, this._parent, this._elements, p.index, 
                                      function (a, b) { return isAbove(b, a); }); 
        break; 
      default: return p;
      }
      return { index: ind, point: centerPoint(getOffsetRectangle(this._parent, this._elements[ind])) };
    }
  
    RowwiseGeometry.prototype.filter = function(p) {   
      var J = multiselect.makeEmptyMap();
      for (var i = 0; i < this._elements.length; ++i) if (p(i)) J.set(i, true);
      return J;
    }
  
    RowwiseGeometry.prototype.defaultCursor = function (dir) {
      var ind;
      switch (dir) {
      case multiselect.RIGHT: 
      case multiselect.DOWN: ind = 0; break;
      case multiselect.LEFT: 
      case multiselect.UP: ind = this._elements.length - 1; break;
      default: return undefined;
      }
      return { index: ind, point: centerPoint(getOffsetRectangle(this._parent, this._elements[ind])) };
    }
  
  // Mouse events
  function setupMouseEvents (parent, canvas, selection) {
  
    function mousedownHandler(evt) {
  
      var mousePos = selection.geometry().m2v(offsetMousePos(parent, evt));
      switch (multiselect.modifierKeys(evt)) {
      case multiselect.NONE: selection.click(mousePos); break;
      case multiselect.CMD: selection.cmdClick(mousePos); break;
      case multiselect.SHIFT: selection.shiftClick(mousePos); break;
      default: return;
      }    
  
      selection.geometry().drawIndicators(selection, canvas, true, true, false);
      document.addEventListener('mousemove', mousemoveHandler, false);
      document.addEventListener('mouseup', mouseupHandler, false);
      evt.preventDefault();
      evt.stopPropagation();
    };
  
    function mousemoveHandler (evt) {
      evt.preventDefault();
      evt.stopPropagation();
      var mousePos = selection.geometry().m2v(offsetMousePos(parent, evt));
      selection.shiftClick(mousePos);
      selection.geometry().drawIndicators(selection, canvas, true, true, true);
    };
  
    function mouseupHandler (evt) {
      document.removeEventListener('mousemove', mousemoveHandler, false);
      document.removeEventListener('mouseup', mouseupHandler, false);
      selection.geometry().drawIndicators(selection, canvas, true, true, false);
    };
  
    parent.addEventListener('mousedown', mousedownHandler, false);
  }
  
  // Keyboard events
    function setupKeyboardEvents(parent, canvas, selection) {
  
      parent.addEventListener('keydown', keydownHandler, false);
      parent.addEventListener('mousedown', function() { parent.focus(); }, false);
  
      function keydownHandler(evt) {
        var handled = false; 
        var mk = multiselect.modifierKeys(evt);
        switch (evt.which) {          
        case 37: handled = callArrow(mk, multiselect.LEFT); break;
        case 38: handled = callArrow(mk, multiselect.UP); break;             
        case 39: handled = callArrow(mk, multiselect.RIGHT); break;
        case 40: handled = callArrow(mk, multiselect.DOWN); break;
        case 32: handled = callSpace(mk); break;
        case 90: handled = callUndoRedo(mk); break;
        default: return; // exit this handler for unrecognized keys
        }
        if (!handled) return; // they key+modifier combination was not recognized
  
        selection.geometry().drawIndicators(selection, canvas, true, true, false);
        evt.preventDefault(); 
        evt.stopPropagation();
      }  
    
      function callUndoRedo (mk) {
        switch (mk) {
        case multiselect.OPT: selection.undo(); break;
        case multiselect.SHIFT_OPT: selection.redo(); break;
        default: return false;
        }      
        return true;
      }
  
      function callArrow (mk, dir) {
        switch (mk) {
        case multiselect.NONE: selection.arrow(dir); break;
        case multiselect.CMD: selection.cmdArrow(dir); break;
        case multiselect.SHIFT: selection.shiftArrow(dir); break;
        default: return false;
        }
        return true;
      }
    
      function callSpace (mk) {
        switch (mk) {
        case multiselect.NONE: selection.space(); break;
        case multiselect.CMD: selection.cmdSpace(); break;
        case multiselect.SHIFT: selection.shiftSpace(); break;
        default: return false;      
        }
        return true;
      }
    }

  document.addEventListener("DOMContentLoaded", function() { 

      var selectableArea2 = document.getElementById("selectable_area2");
      for (var i = 0; i<400; ++i) {
        var e = document.createElement("span");
        e.setAttribute("class", "selectable2");
        e.textContent = i;
        selectableArea2.appendChild(e);
      }
    
      var selectables2 = selectableArea2.getElementsByClassName("selectable2");
    
    var refresh2 = mkRefresh(selectables2, 'selected2');
    
      var geometry2 = new RowwiseGeometry(selectableArea2, selectables2);
      var selection2 = new multiselect.SelectionState(geometry2, refresh2, true);
    
      var canvas2 = createCanvas(selectableArea2);
      setupMouseEvents(selectableArea2, canvas2, selection2);
    setupKeyboardEvents(selectableArea2, canvas2, selection2);
    
      geometry2.drawIndicators = function (selection, canvas, drawAnchor, drawCursor, drawRubber) {
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (drawAnchor) { 
          ctx.strokeStyle = 'DarkRed';
          var p = multiselect.anchor(selection.selectionPath());
          if (p !== undefined) {
            if (p.index === null) { // in-between point, draw a circle
              ctx.beginPath();
              ctx.arc(p.point.x, p.point.y, 4, 0, Math.PI*2, true); 
              ctx.stroke();
            } else { // point on an element, draw a frame
              var r = getOffsetRectangle(canvas, selection.geometry()._elements[p.index]);
              ctx.strokeRect(r.left, r.top, r.right-r.left, r.bottom-r.top);
            }
          }
        }
        if (drawCursor) { 
          ctx.strokeStyle = 'blue';
          var p = selection.cursor();
          if (p !== undefined && p.index !== null) { 
            var r = getOffsetRectangle(canvas, selection.geometry()._elements[p.index]);
            ctx.strokeRect(r.left, r.top, r.right-r.left, r.bottom-r.top);
          }
        }
        if (drawRubber) { 
          ctx.strokeStyle = 'green';
          var p1 = multiselect.anchor(selection.selectionPath());
          if (p1 !== undefined && p1.index === null) {
            var p2 = multiselect.activeEnd(selection.selectionPath());
            ctx.strokeRect(Math.min(p1.point.x, p2.point.x),
                           Math.min(p1.point.y, p2.point.y),
                           Math.abs(p1.point.x-p2.point.x),
                           Math.abs(p1.point.y-p2.point.y));
          }
        }
      }

  });
</script>

<p>
This section introduces a selection context that has a rather complex
selection geometry.  The elements are ordered row-wise, similarly to
how characters of text are ordered in an editor.  The anchor and the
active end can be interpreted either as the end points of a range of
elements in this order, or as the corners of a rectangular area. The
user can use both of these mechanisms interchangeably.  This kind of a
dual selection mechanism is offered, for example, in Apple&rsquo;s Photos
application.
</p>

<p target="_blank">
This section also shows how to support rubber band selection
and selecting using the keyboard, how to support the undo and redo operations, and how to
visualize the anchor, the active end, and the rubber band.  Again, 
the <a href="example-2.html" target="_blank">example</a> and its 
<a href="javascript:viewSource('example-2.html')">
complete source code</a> can be viewed in separate windows.
</p>

  <style>
    #selectable_area2 { border:1px solid black; cursor:default; }
    .selectable2 { outline:1px solid; padding:1px 4px 1px 4px; 
                   margin:2px; display:inline-block; }
    .selected2 { background-color: khaki; }
  </style>
<div id="selectable_area2" tabIndex="0"></div>

<p>
To become familiar with the supported selection features, try
clicking, command-clicking, and shift clicking the elements, as well
as dragging the mouse to initiate a rubber band selection. Try starting a
rubber band selection both on an element and between elements, and
notice how the former initiates a row-wise selection and the latter 
a rectangular selection. Try starting a rubber
band <i>deselection</i> with a command-click on a selected element.  Try
releasing the mouse in a rubber band selection, and then picking it up
again with shift-click to continue with the rubber band. To experiment with 
selecting with the keyboard, try the
space and arrow keys with and without the shift and command
modifiers. Finally, use the undo and redo operations that are, respectively, 
bound to option-Z and shift-option-Z keys.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Selectable elements</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The selectable area is a <code>div</code>. The <code>tabIndex</code> attribute is defined so that
the element can acquire the keyboard focus.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-html">&lt;div id=<span style="color: #008000;">"selectable_area2"</span> tabIndex=<span style="color: #008000;">"0"</span>&gt;&lt;/div&gt;
</pre>
</div>

<p>
In this example, the selectable elements are generated by JavaScript code:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-selectables">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectableArea2</span> = document.getElementById(<span style="color: #008000;">"selectable_area2"</span>);
  <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span> = 0; i&lt;400; ++i) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">e</span> = document.createElement(<span style="color: #008000;">"span"</span>);
    e.setAttribute(<span style="color: #008000;">"class"</span>, <span style="color: #008000;">"selectable2"</span>);
    e.textContent = i;
    selectableArea2.appendChild(e);
  }

  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectables2</span> = selectableArea2.getElementsByClassName(<span style="color: #008000;">"selectable2"</span>);
</pre>
</div>

<p>
We again use CSS and classes to visualize the selection state.
The <code>selectable2</code> class indicates a selectable element and the <code>selected2</code> class
an element that is currently selected. The style definitions are as follows:
</p>

<div class="org-src-container">

<pre class="src src-html" id="row-wise-css">  &lt;<span style="color: #006699;">style</span>&gt;
    #selectable_area2 { border:1px solid black; cursor:default; }
    .selectable2 { outline:1px solid; padding:1px 4px 1px 4px; 
                   margin:2px; display:inline-block; }
    .selected2 { background-color: khaki; }
  &lt;/<span style="color: #006699;">style</span>&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-refreshing-and-tracking" class="outline-3">
<h3 id="sec-refreshing-and-tracking"><a id="sec-3-2"></a><span class="section-number-3">3.2</span> Refreshing</h3>
<div class="outline-text-3" id="text-sec-refreshing-and-tracking">
<p>
As discussed above, every method of the <code>SelectionState</code> class that
may change the selection state invokes the refresh callback.  This
example uses <i>tracking of changes</i> so that the refresh callback
function only needs to iterate over the changed elements, instead of
all selectable elements. We use a refresh function that toggles a class 
in further examples as well, and thus write a factory function
that can generate a refresh-callback for any set of DOM elements.
</p>

<div class="org-src-container">

<pre class="src src-js" id="mk-refresh"><span style="color: #0000FF;">function</span> <span style="color: #006699;">mkRefresh</span> (<span style="color: #BA36A5;">elements</span>, <span style="color: #BA36A5;">cls</span>) {
  <span style="color: #0000FF;">return</span> (<span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">changed</span>) {
    changed.forEach(<span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">value</span>, <span style="color: #BA36A5;">i</span>) { 
      $(elements[i]).toggleClass(cls, value); 
    });
  });
}
</pre>
</div>

<p>
The refresh function for this current example is:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-refresh"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">refresh2</span> = mkRefresh(selectables2, <span style="color: #008000;">'selected2'</span>);
</pre>
</div>


<p>
With tracking of changes on, the argument to the refresh callback is a
<code>Map</code> object. Its keys are the indices of the elements that were
changed and its values are either <code>true</code> or <code>false</code>, each indicating whether 
an element is selected or not.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Selection geometry</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The selection geometry again stores a reference to the collection of
the selectable elements. It also stores a reference to a DOM object
surrounding the selectable elements. We use mouse coordinates that are
relative to this <code>parent</code> object&rsquo;s location on the page.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">RowwiseGeometry</span> = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">elements</span>) {
  <span style="color: #8b1a1a;">this</span>._parent = parent;
  <span style="color: #8b1a1a;">this</span>._elements = elements;
}
RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span> = Object.create(multiselect.DefaultGeometry.<span style="color: #8b1a1a;">prototype</span>);
</pre>
</div>

<p>
Coordinates in the selection space can indicate either an element
index or a point ``in-between&rsquo;&rsquo;.  We choose to represent a coordinate
as an object that has two members, <code>index</code> and <code>point</code>. The in-between
coordinate values are recognized by <code>index</code> that has the value <code>null</code>.  
The <code>m2v</code> method thus maps a mouse location <code>mp</code>, which is relative to <code>parent</code>, 
to a coordinate object whose <code>point</code> member is <code>mp</code> and whose <code>index</code> member is either <code>null</code> or
the index of one of the elements.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry-m2v">  RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span>.m2v = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">mp</span>) {
    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=0; i&lt;<span style="color: #8b1a1a;">this</span>._elements.length; ++i) {
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r</span> = getOffsetRectangle(<span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements[i]);
      <span style="color: #0000FF;">if</span> (pointInRectangle(mp, r)) <span style="color: #0000FF;">return</span> { index: i, point: mp };        
    }
    <span style="color: #0000FF;">return</span> { index: <span style="color: #8b1a1a;">null</span>, point: mp };
  }
</pre>
</div>

<p>
The utility function <code>getOffsetRectangle(a, b)</code> function computes the bounding box of <code>b</code> in
coordinates relative to the top-left corner of the bounding box of <code>a</code>:
</p>

<div class="org-src-container">

<pre class="src src-js" id="get-offset-rectangle">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">topLeftCorner</span>(<span style="color: #BA36A5;">r</span>) { <span style="color: #0000FF;">return</span> { x: r.left, y: r.top }; }
    
  <span style="color: #0000FF;">function</span> <span style="color: #006699;">offsetRectangle</span>(<span style="color: #BA36A5;">p</span>, <span style="color: #BA36A5;">r</span>) {
    <span style="color: #0000FF;">return</span> {
      left: r.left - p.x, top: r.top - p.y, 
      right: r.right - p.x, bottom: r.bottom - p.y 
    };
  }

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">getOffsetRectangle</span>(<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">elem</span>) {
    <span style="color: #0000FF;">return</span> offsetRectangle(topLeftCorner(parent.getBoundingClientRect()),
                           elem.getBoundingClientRect());
  }
</pre>
</div>

<p>
As mentioned above, the user can select either a range or a rectangular area
of elements. Which mechanism is used depends on from where a selection
command starts: if the anchor is on an element, a range is selected;
if the anchor is in-between elements, a rectangular area is selected.
The <code>selectionDomain</code>
function thus first inspects the anchor&rsquo;s <code>index</code> to determine the
kind of coordinate the anchor is, and then interprets the
anchor and the active end either as the endpoints of a range or as the
corners of a rectangle:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry-selection-domain">  RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span>.selectionDomain = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">path</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">J</span> = multiselect.makeEmptyMap();
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">a</span> = multiselect.anchor(path);
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">b</span> = multiselect.activeEnd(path);

    <span style="color: #0000FF;">if</span> (a.index !== <span style="color: #8b1a1a;">null</span>) { <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">path defines a range</span>
      <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=Math.min(a.index, b.index); i&lt;=Math.max(a.index, b.index); ++i) 
        J.set(i, <span style="color: #8b1a1a;">true</span>);
    } <span style="color: #0000FF;">else</span> {                <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">path defines a rectangle</span>
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r1</span> = { left:   Math.min(a.point.x, b.point.x),
                 right:  Math.max(a.point.x, b.point.x),
                 top:    Math.min(a.point.y, b.point.y),
                 bottom: Math.max(a.point.y, b.point.y) };
      <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span> = 0; i &lt; <span style="color: #8b1a1a;">this</span>._elements.length; ++i) {
        <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r2</span> = getOffsetRectangle(<span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements[i]);
        <span style="color: #0000FF;">if</span> (rectangleIntersect(r1, r2)) J.set(i, <span style="color: #8b1a1a;">true</span>);
      }
    }

    <span style="color: #0000FF;">return</span> J;
  }
</pre>
</div>

<p>
The <code>rectangeIntersect</code> helper function is as follows:
</p>

<div class="org-src-container">

<pre class="src src-js" id="rectangle-intersect">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">rectangleIntersect</span>(<span style="color: #BA36A5;">r1</span>, <span style="color: #BA36A5;">r2</span>) {
    <span style="color: #0000FF;">return</span> r1.left &lt;= r2.right  &amp;&amp; r1.right  &gt;= r2.left &amp;&amp; 
           r1.top  &lt;= r2.bottom &amp;&amp; r1.bottom &gt;= r2.top;
  }
</pre>
</div>

<p>
This selection geometry also overrides the <code>extendPath(path, p)</code> method.  The
<code>click</code>, <code>cmdClick</code>, and <code>shiftClick</code> methods call <code>extendPath</code> to add
a selection space point to the current selection path. Prior to
pushing the new point to the <code>path</code> array, this <code>extendPath</code>
implementation performs two tasks.  First, only the first and last
point of the selection path (anchor and active end) are of importance
in this geometry. Therefore, if the path already 
has two elements, the previous active end is discarded.<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup> 
Second, if the anchor is on an element, we insist
that the active end is also on an element: trying to extend the path
with an in-between point has no effect in this case.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry-extend-path">  RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span>.extendPath = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">path</span>, <span style="color: #BA36A5;">p</span>) {
    <span style="color: #0000FF;">if</span> (path.length &gt; 0 &amp;&amp;
        multiselect.anchor(path).index !== <span style="color: #8b1a1a;">null</span> &amp;&amp; p.index === <span style="color: #8b1a1a;">null</span>) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">null</span>;
    <span style="color: #0000FF;">if</span> (path.length == 2) path.pop();
    path.push(p); 
  }
</pre>
</div>

<p>
By returning <code>null</code> when the selection path is not changed, the <code>extendPath</code>
function informs the library that the selection domain does not have to be
recalculated.
</p>
</div>
</div>

<div id="outline-container-sec-create-selection-state-2" class="outline-3">
<h3 id="sec-create-selection-state-2"><a id="sec-3-4"></a><span class="section-number-3">3.4</span> Selection state object</h3>
<div class="outline-text-3" id="text-sec-create-selection-state-2">
<p>
The <code>SelectionState</code> object is created as in the first example. This time, however,
we set tracking to <code>true</code> since we defined the <code>refresh2</code> callback to expect
a map of the changed elements as its parameter.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-create-selection-state">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">geometry2</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">RowwiseGeometry</span>(selectableArea2, selectables2);
  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selection2</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">multiselect.SelectionState</span>(geometry2, refresh2, <span style="color: #8b1a1a;">true</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Mouse events</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Setting up mouse events for the current example is a bit more involved because
supporting rubber band selection requires handlers also for the <code>mousemove</code> and
<code>mouseup</code> events. Furthermore, in addition to the selection status of the
elements, this example visualizes the anchor, active end, and the rubber band, which
adds a few function calls to the handlers.
</p>

<p>
The interplay between the handlers of different mouse events can be designed in
many ways&#x2014;the code below should be considered as one possible
arrangement. The handler for the <code>mousedown</code> event in the selectable
area (<code>parent</code>) is registered at all times.  After a command that it recognizes, this handler
registers the handlers for the <code>mousemove</code> and <code>mouseup</code> events. These are recognized
within the entire document, as the mouse can wander outside of the
selectable area.  The handler for the <code>mouseup</code> event de-registers itself
and the <code>mousemove</code> handler.
</p>

<div class="org-src-container">

<pre class="src src-js" id="setup-mouse-events"><span style="color: #0000FF;">function</span> <span style="color: #006699;">setupMouseEvents</span> (<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">canvas</span>, <span style="color: #BA36A5;">selection</span>) {

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">mousedownHandler</span>(<span style="color: #BA36A5;">evt</span>) {

    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">mousePos</span> = selection.geometry().m2v(offsetMousePos(parent, evt));
    <span style="color: #0000FF;">switch</span> (multiselect.modifierKeys(evt)) {
    <span style="color: #0000FF;">case</span> multiselect.NONE: selection.click(mousePos); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.CMD: selection.cmdClick(mousePos); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.SHIFT: selection.shiftClick(mousePos); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span>;
    }    

    selection.geometry().drawIndicators(selection, canvas, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">false</span>);
    document.addEventListener(<span style="color: #008000;">'mousemove'</span>, mousemoveHandler, <span style="color: #8b1a1a;">false</span>);
    document.addEventListener(<span style="color: #008000;">'mouseup'</span>, mouseupHandler, <span style="color: #8b1a1a;">false</span>);
    evt.preventDefault();
    evt.stopPropagation();
  };

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">mousemoveHandler</span> (<span style="color: #BA36A5;">evt</span>) {
    evt.preventDefault();
    evt.stopPropagation();
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">mousePos</span> = selection.geometry().m2v(offsetMousePos(parent, evt));
    selection.shiftClick(mousePos);
    selection.geometry().drawIndicators(selection, canvas, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">true</span>);
  };

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">mouseupHandler</span> (<span style="color: #BA36A5;">evt</span>) {
    document.removeEventListener(<span style="color: #008000;">'mousemove'</span>, mousemoveHandler, <span style="color: #8b1a1a;">false</span>);
    document.removeEventListener(<span style="color: #008000;">'mouseup'</span>, mouseupHandler, <span style="color: #8b1a1a;">false</span>);
    selection.geometry().drawIndicators(selection, canvas, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">false</span>);
  };

  parent.addEventListener(<span style="color: #008000;">'mousedown'</span>, mousedownHandler, <span style="color: #8b1a1a;">false</span>);
}
</pre>
</div>

<p>
There are three further noteworthy issues in the code above.  
</p>

<ol class="org-ol">
<li>A mouse move during rubber band selection is semantically
equivalent to a shift-click. The <code>mousemoveHandler</code> thus acquires a
selection space coordinate and passes it to the <code>shiftClick</code> method.</li>

<li>The calls to <code>drawIndicators</code> function are what display the anchor,
the active end, and the rubber band indicators. These markers are
drawn on a HTML5 <i>canvas</i> element that overlaps the selectable
area.  The three boolean arguments specify which of the three
indicators (in the order anchor, active end, rubber band) should be
shown; <code>true</code> means to show, <code>false</code> to hide.  In this example we
make <code>drawIndicators</code> a method of the geometry object.  This
is because we reuse the <code>setupMouseEvents</code> function in a later example
that uses a different selection geometry. A different geometry
usually means a different visualization, so it is convenient that the geometry object
brings along this visualization function.</li>

<li>Even though the mouse events are a bit more complex than in the first example, 
MultiselectJS&rsquo;s selection services are obtained by the same simple calls
to the three different click methods.</li>
</ol>

<p>
We remark that a common feature in multi-selection contexts is
drag-and-drop of selected elements. The above event handlers do not
recognize the start of a drag-and-drop event.
</p>

<p>
A few tasks remain. First, the mouse setup code uses the helper function
<code>offsetMousePos</code> to translate an event&rsquo;s mouse coordinates to 
coordinates relative to another DOM element (<code>parent</code>). Its implementation
is as follows:
</p>

<div class="org-src-container">

<pre class="src src-js" id="offset-mouse-pos">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">offsetMousePos</span>(<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">evt</span>) { 
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = topLeftCorner(parent.getClientRects()[0]);
    <span style="color: #0000FF;">return</span> { x: evt.clientX - p.x, y: evt.clientY - p.y }; 
  }
</pre>
</div>

<p>
Second, the event handlers must be activated:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-setup-mouse-events">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">canvas2</span> = createCanvas(selectableArea2);
  setupMouseEvents(selectableArea2, canvas2, selection2);
</pre>
</div>

<p>
Section <a href="#sec-path-visualization">3.7</a> shows the implementations of the
<code>createCanvas</code> and <code>drawIndicators</code> functions.
</p>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Keyboard events</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Various keyboard commands can accomplish the same selection tasks as
clicks&#x2014;the selection space point associated with a keyboard command
is the value of the <i>keyboard cursor</i>.  The keyboard cursor is often
the same as the active end; a click, command-click, and shift-click
set the cursor to and the active end to the clicked point.  The cursor
can, however, deviate from the active end.  For example, the arrow
keys, unmodified, move the keyboard cursor but do not change the
selection path. Further, the keyboard cursor can be defined even if
the selection path is empty, e.g., after an <code>undo</code> command.
</p>

<p>
Selection geometry&rsquo;s <code>step(dir, point)</code> method determines how arrow
keys move the keyboard cursor. The <code>dir</code> parameter is one of constants
<code>UP</code>, <code>DOWN</code>, <code>LEFT</code>, <code>RIGHT</code>. In this example, <code>step</code> only moves the
cursor if it is on an element. When moving to a new element, the
<code>point</code> member of the cursor object is set to the center point of the
moved-to element.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry-step">  RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span>.step = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">dir</span>, <span style="color: #BA36A5;">p</span>) {
    <span style="color: #0000FF;">if</span> (p.index === <span style="color: #8b1a1a;">null</span>) <span style="color: #0000FF;">return</span> p; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">p is an "in-between" point, no change</span>
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">ind</span> = <span style="color: #8b1a1a;">null</span>;
    <span style="color: #0000FF;">switch</span> (dir) {
    <span style="color: #0000FF;">case</span> multiselect.LEFT:  ind = Math.max(p.index - 1, 0); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.RIGHT: ind = Math.min(p.index + 1, <span style="color: #8b1a1a;">this</span>._elements.length-1); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.UP: 
      ind = findClosestP.call(<span style="color: #8b1a1a;">this</span>, <span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements, p.index, isAbove); 
      <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.DOWN: 
      ind = findClosestP.call(<span style="color: #8b1a1a;">this</span>, <span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements, p.index, 
                                    <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">a</span>, <span style="color: #BA36A5;">b</span>) { <span style="color: #0000FF;">return</span> isAbove(b, a); }); 
      <span style="color: #0000FF;">break</span>; 
    <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span> p;
    }
    <span style="color: #0000FF;">return</span> { index: ind, point: centerPoint(getOffsetRectangle(<span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements[ind])) };
  }
</pre>
</div>

<p>
Moving left and right is simple: decrement or increment the cursor&rsquo;s
index.  Moving up or down is more complex. There are several sensible
choices for what <i>the next element above</i> and <i>the next element
below</i> could mean, even the notions of <i>above</i> and <i>below</i> are ambiguous.
Here we consider one element to be above another if the former&rsquo;s
center point is above the top edge of the latter. The next element
above of some element <code>i</code> is the closest, in distance between center
points, of all elements that are above <code>i</code>. The next element below is defined
analogously. The <code>findClosestP(parent, elements, i, pred)</code> helper function 
performs these determinations, finding the closest element to <code>i</code> 
that satisfies <code>pred</code>:
</p>

<div class="org-src-container">

<pre class="src src-js" id="rectangle-helpers-3">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">centerPoint</span> (<span style="color: #BA36A5;">r</span>) { <span style="color: #0000FF;">return</span> { x: (r.left + r.right)/2, 
                                      y: (r.top + r.bottom)/2 }; }

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">distance</span> (<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">dx</span> = p1.x - p2.x;
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">dy</span> = p1.y - p2.y;
    <span style="color: #0000FF;">return</span> Math.sqrt(dx * dx + dy * dy);
  }

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">isAbove</span>(<span style="color: #BA36A5;">r1</span>, <span style="color: #BA36A5;">r2</span>) { <span style="color: #0000FF;">return</span> centerPoint(r2).y &lt; r1.top; }

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">findClosestP</span>(<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">elements</span>, <span style="color: #BA36A5;">j</span>, <span style="color: #BA36A5;">pred</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r</span> = getOffsetRectangle(parent, elements[j]);
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">candidateIndex</span> = <span style="color: #8b1a1a;">null</span>; 
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">candidateDistance</span> = Number.MAX_VALUE;

    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=0; i&lt;elements.length; ++i) {
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">rc</span> = getOffsetRectangle(parent, elements[i]);
      <span style="color: #0000FF;">if</span> (pred(r, rc) &amp;&amp; distance(centerPoint(r), centerPoint(rc)) &lt; candidateDistance) {
        candidateIndex = i; 
        candidateDistance = distance(centerPoint(r), centerPoint(rc));
      }
    }
    <span style="color: #0000FF;">if</span> (candidateIndex === <span style="color: #8b1a1a;">null</span>) <span style="color: #0000FF;">return</span> j; <span style="color: #0000FF;">else</span> <span style="color: #0000FF;">return</span> candidateIndex;
  }
</pre>
</div>

<p>
With the <code>step</code> function defined, setting up the keyboard events is
straightforward: the event handler for <code>keydown</code> recognizes the key
combination of a command, invokes the desired <code>SelectionState</code>&rsquo;s
method, and calls the function that draws the indicators.  To avoid
conflicts, we bind the handler to <code>parent</code>, which is the selectable area.
In this way the bindings are only in effect when <code>parent</code> has
the focus. A new <code>mousedown</code> handler is added to give <code>parent</code> the focus when
anything within it is clicked.
</p>

<div class="org-src-container">

<pre class="src src-js" id="setup-keyboard-events">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">setupKeyboardEvents</span>(<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">canvas</span>, <span style="color: #BA36A5;">selection</span>) {

    parent.addEventListener(<span style="color: #008000;">'keydown'</span>, keydownHandler, <span style="color: #8b1a1a;">false</span>);
    parent.addEventListener(<span style="color: #008000;">'mousedown'</span>, <span style="color: #0000FF;">function</span>() { parent.focus(); }, <span style="color: #8b1a1a;">false</span>);

    <span style="color: #0000FF;">function</span> <span style="color: #006699;">keydownHandler</span>(<span style="color: #BA36A5;">evt</span>) {
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">handled</span> = <span style="color: #8b1a1a;">false</span>; 
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">mk</span> = multiselect.modifierKeys(evt);
      <span style="color: #0000FF;">switch</span> (evt.which) {          
      <span style="color: #0000FF;">case</span> 37: handled = callArrow(mk, multiselect.LEFT); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 38: handled = callArrow(mk, multiselect.UP); <span style="color: #0000FF;">break</span>;             
      <span style="color: #0000FF;">case</span> 39: handled = callArrow(mk, multiselect.RIGHT); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 40: handled = callArrow(mk, multiselect.DOWN); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 32: handled = callSpace(mk); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 90: handled = callUndoRedo(mk); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">exit this handler for unrecognized keys</span>
      }
      <span style="color: #0000FF;">if</span> (!handled) <span style="color: #0000FF;">return</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">they key+modifier combination was not recognized</span>

      selection.geometry().drawIndicators(selection, canvas, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">false</span>);
      evt.preventDefault(); 
      evt.stopPropagation();
    }  
  
    <span style="color: #0000FF;">function</span> <span style="color: #006699;">callUndoRedo</span> (<span style="color: #BA36A5;">mk</span>) {
      <span style="color: #0000FF;">switch</span> (mk) {
      <span style="color: #0000FF;">case</span> multiselect.OPT: selection.undo(); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> multiselect.SHIFT_OPT: selection.redo(); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">false</span>;
      }      
      <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
    }

    <span style="color: #0000FF;">function</span> <span style="color: #006699;">callArrow</span> (<span style="color: #BA36A5;">mk</span>, <span style="color: #BA36A5;">dir</span>) {
      <span style="color: #0000FF;">switch</span> (mk) {
      <span style="color: #0000FF;">case</span> multiselect.NONE: selection.arrow(dir); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> multiselect.CMD: selection.cmdArrow(dir); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> multiselect.SHIFT: selection.shiftArrow(dir); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">false</span>;
      }
      <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
    }
  
    <span style="color: #0000FF;">function</span> <span style="color: #006699;">callSpace</span> (<span style="color: #BA36A5;">mk</span>) {
      <span style="color: #0000FF;">switch</span> (mk) {
      <span style="color: #0000FF;">case</span> multiselect.NONE: selection.space(); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> multiselect.CMD: selection.cmdSpace(); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> multiselect.SHIFT: selection.shiftSpace(); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">false</span>;      
      }
      <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
    }
  }
</pre>
</div>

<p>
The main switch statement recognizes the arrow
keys, space, and the character <code>z</code> (for undo and redo), and delegates
to different helper functions. The helper functions inspect the
modifiers and dispatch to the appropriate <code>SelectionState</code> method,
or return <code>false</code> if the key binding is not recognized.
</p>

<p>
A call to <code>setupKeyboardEvents</code> registers the keyboard event handler:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-setup-keyboard-events">setupKeyboardEvents(selectableArea2, canvas2, selection2);
</pre>
</div>

<p>
To complete the keyboard selection functionality, we override the
<code>defaultCursor</code> method so that the keyboard cursor has sensible defaults
when nothing has yet been selected: the arrow right and arrow down keys
start from the first element, the arrow left and arrow up keys from the last.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry-default-cursor">  RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span>.defaultCursor = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">dir</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">ind</span>;
    <span style="color: #0000FF;">switch</span> (dir) {
    <span style="color: #0000FF;">case</span> multiselect.RIGHT: 
    <span style="color: #0000FF;">case</span> multiselect.DOWN: ind = 0; <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.LEFT: 
    <span style="color: #0000FF;">case</span> multiselect.UP: ind = <span style="color: #8b1a1a;">this</span>._elements.length - 1; <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">undefined</span>;
    }
    <span style="color: #0000FF;">return</span> { index: ind, point: centerPoint(getOffsetRectangle(<span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements[ind])) };
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-path-visualization" class="outline-3">
<h3 id="sec-path-visualization"><a id="sec-3-7"></a><span class="section-number-3">3.7</span> Visualizing anchor, cursor, and rubber band</h3>
<div class="outline-text-3" id="text-sec-path-visualization">
<p>
Sometimes it is useful to show where the anchor, active end, and keyboard cursor
reside. Many expect to see a rectangular rubber band when selecting
via dragging. In &ldquo;lasso&rdquo; selection, it is particularly important to
have a visual indicator of the selected area.  To display such indicators
is outside of MultiselectJS. To help in the task, however, <code>SelectionState</code> 
has the methods <code>selectionPath()</code> and <code>cursor()</code> 
that return the current selection path and cursor, respectively.  The
former returns an array of points and the latter a single point. These
points are selection space coordinates and thus something akin to an
inverse of the <code>m2v</code> transformation is necessary prior to their use in
visualization. The desired visualization, however, is likely not a
single point, but instead perhaps a frame over the selected
element. Since the details of the &ldquo;inverse&rdquo; transformation varies from
one selection context to another, its definition is left to
the client.
</p>

<p>
In this example the visual indicators are drawn on a canvas that is placed on
top of the selectable area. So that the canvas tracks the selectable 
area at all times, the canvas&rsquo; size
and position are recalculated whenever the <code>window</code> object is resized.
</p>

<div class="org-src-container">

<pre class="src src-js" id="create-canvas"><span style="color: #0000FF;">function</span> <span style="color: #006699;">createCanvas</span> (<span style="color: #BA36A5;">parent</span>) {

  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">canvas</span> = document.createElement(<span style="color: #008000;">"canvas"</span>);
  canvas.style.position = <span style="color: #008000;">'absolute'</span>;
  parent.insertBefore(canvas, parent.firstChild);

  $(window).resize(resizeCanvas); 
  resizeCanvas();

  <span style="color: #0000FF;">return</span> canvas;

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">resizeCanvas</span>() {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">rect</span> = parent.getBoundingClientRect();
    canvas.width = rect.right - rect.left;
    canvas.height = rect.bottom - rect.top;    
  }
}
</pre>
</div>

<p>
The <code>drawIndicators</code> function is defined as a method of the
<code>geometry2</code> object. The function first clears all indicators, then
draws some or all of anchor, cursor, and rubber band based on the
<code>drawAnchor</code>, <code>drawCursor</code>, and <code>drawRubber</code> flags.  The tests for
<code>undefined</code> points are to safeguard for the case where there is no
anchor (the selection path is empty) or no cursor.
</p>

<p>
The anchor is drawn as a circle if it is an in-between point (a point whose
<code>index</code> is <code>null</code>) and as a rectangle if it is on an element.
The cursor is not drawn at all for in-between points. 
</p>

<div class="org-src-container">

<pre class="src src-js" id="draw-indicators">  geometry2.drawIndicators = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">selection</span>, <span style="color: #BA36A5;">canvas</span>, <span style="color: #BA36A5;">drawAnchor</span>, <span style="color: #BA36A5;">drawCursor</span>, <span style="color: #BA36A5;">drawRubber</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">ctx</span> = canvas.getContext(<span style="color: #008000;">'2d'</span>);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    <span style="color: #0000FF;">if</span> (drawAnchor) { 
      ctx.strokeStyle = <span style="color: #008000;">'DarkRed'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = multiselect.anchor(selection.selectionPath());
      <span style="color: #0000FF;">if</span> (p !== <span style="color: #8b1a1a;">undefined</span>) {
        <span style="color: #0000FF;">if</span> (p.index === <span style="color: #8b1a1a;">null</span>) { <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">in-between point, draw a circle</span>
          ctx.beginPath();
          ctx.arc(p.point.x, p.point.y, 4, 0, Math.PI*2, <span style="color: #8b1a1a;">true</span>); 
          ctx.stroke();
        } <span style="color: #0000FF;">else</span> { <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">point on an element, draw a frame</span>
          <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r</span> = getOffsetRectangle(canvas, selection.geometry()._elements[p.index]);
          ctx.strokeRect(r.left, r.top, r.right-r.left, r.bottom-r.top);
        }
      }
    }
    <span style="color: #0000FF;">if</span> (drawCursor) { 
      ctx.strokeStyle = <span style="color: #008000;">'blue'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = selection.cursor();
      <span style="color: #0000FF;">if</span> (p !== <span style="color: #8b1a1a;">undefined</span> &amp;&amp; p.index !== <span style="color: #8b1a1a;">null</span>) { 
        <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r</span> = getOffsetRectangle(canvas, selection.geometry()._elements[p.index]);
        ctx.strokeRect(r.left, r.top, r.right-r.left, r.bottom-r.top);
      }
    }
    <span style="color: #0000FF;">if</span> (drawRubber) { 
      ctx.strokeStyle = <span style="color: #008000;">'green'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p1</span> = multiselect.anchor(selection.selectionPath());
      <span style="color: #0000FF;">if</span> (p1 !== <span style="color: #8b1a1a;">undefined</span> &amp;&amp; p1.index === <span style="color: #8b1a1a;">null</span>) {
        <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p2</span> = multiselect.activeEnd(selection.selectionPath());
        ctx.strokeRect(Math.min(p1.point.x, p2.point.x),
                       Math.min(p1.point.y, p2.point.y),
                       Math.abs(p1.point.x-p2.point.x),
                       Math.abs(p1.point.y-p2.point.y));
      }
    }
  }
</pre>
</div>

<p>
The second example is complete.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Example: snake selection geometry</h2>
<div class="outline-text-2" id="text-4">
<p>
The third example demonstrates a selection geometry where all points
of the selection path are relevant. The selection domain is defined as 
all those elements that the selection path touches.<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>
Please experiment with the selection context to understand
how this ``snake&rsquo;&rsquo; selection works. 
</p>

<p>
This example also demonstrates selecting elements based on a predicate.
Instead of numbers, the selectable elements in this example are fish. 
When the <i>Filter</i> field is modified, all fish names that contain
the filter as a substring become selected. Modifying the filter
updates the active selection domain in a similar manner than 
shift-click; the commit button fixes the current active selection 
domain as an undoable state.
</p>

<p target="_blank">
The <a href="example-3.html" target="_blank">example</a> and its 
<a href="javascript:viewSource('example-3.html')">
complete source code</a> can be viewed in separate windows.
</p>

<div id="selectable_area3" tabIndex="0"></div><br>
Filter: <input type="text" id="filter3"></input><button id="commit_filter3">Commit</button> 
<style> 
  #selectable_area3 { border:1px solid black; cursor:default; } 
</style>
<script>
    function pointInRectangle(mp, r) {
      return mp.x >= r.left && mp.x <= r.right && 
             mp.y >= r.top  && mp.y <= r.bottom;
    }
  
    function rectangleIntersect(r1, r2) {
      return r1.left <= r2.right  && r1.right  >= r2.left && 
             r1.top  <= r2.bottom && r1.bottom >= r2.top;
    }
  
    function topLeftCorner(r) { return { x: r.left, y: r.top }; }
      
    function offsetRectangle(p, r) {
      return {
        left: r.left - p.x, top: r.top - p.y, 
        right: r.right - p.x, bottom: r.bottom - p.y 
      };
    }
  
    function getOffsetRectangle(parent, elem) {
      return offsetRectangle(topLeftCorner(parent.getBoundingClientRect()),
                             elem.getBoundingClientRect());
    }
  
    function offsetMousePos(parent, evt) { 
      var p = topLeftCorner(parent.getClientRects()[0]);
      return { x: evt.clientX - p.x, y: evt.clientY - p.y }; 
    }
  
  // canvas that tracks the size of parent
  function createCanvas (parent) {
  
    var canvas = document.createElement("canvas");
    canvas.style.position = 'absolute';
    parent.insertBefore(canvas, parent.firstChild);
  
    $(window).resize(resizeCanvas); 
    resizeCanvas();
  
    return canvas;
  
    function resizeCanvas() {
      var rect = parent.getBoundingClientRect();
      canvas.width = rect.right - rect.left;
      canvas.height = rect.bottom - rect.top;    
    }
  }
  
  // refresh callback
  function mkRefresh (elements, cls) {
    return (function (changed) {
      changed.forEach(function (value, i) { 
        $(elements[i]).toggleClass(cls, value); 
      });
    });
  }
  
  var fish = 
  [ "anchovy"
  , "angelfish"
  , "angelshark"
  , "barb"
  , "barracuda"
  , "basking shark"
  , "bass"
  , "blenny"
  , "blowfish"
  , "bluefin tuna"
  , "blue shark"
  , "bonito"
  , "bony fish"
  , "bull shark"
  , "carp"
  , "catfish"
  , "chub"
  , "clownfish"
  , "cod"
  , "coelacanth"
  , "cookiecutter shark"
  , "crappie"
  , "darter"
  , "devil ray"
  , "dogfish"
  , "dory"
  , "dragonfish"
  , "Dunkleosteus"
  , "eel"
  , "electric eel"
  , "elver"
  , "Emperor angelfish"
  , "fish"
  , "flounder"
  , "flying fish"
  , "Galapagos shark"
  , "gar"
  , "glassfish"
  , "goby"
  , "goldfish"
  , "grayling"
  , "great white shark"
  , "Greenland shark"
  , "grouper"
  , "grunion"
  , "gulper eel"
  , "guppy"
  , "haddock"
  , "hagfish"
  , "hake"
  , "halibut"
  , "hammerhead shark"
  , "hatchetfish"
  , "herring"
  , "humuhumu-nukunuku-apua'a"
  , "icefish"
  , "jackfish"
  , "john dory"
  , "koi"
  , "lake trout"
  , "lamprey"
  , "lanternfish"
  , "lemon shark"
  , "ling cod"
  , "loach"
  , "luminous shark"
  , "lungfish"
  , "mackerel"
  , "mako shark"
  , "manta ray"
  , "marlin"
  , "Megalodon"
  , "megamouth shark"
  , "minnow"
  , "monkfish"
  , "moray eel"
  , "mullet"
  , "needlefish"
  , "nurse shark"
  , "oarfish"
  , "orange roughy"
  , "Orthacanthus"
  , "paddlefish"
  , "parrotfish"
  , "perch"
  , "pike"
  , "pilot fish"
  , "piranha"
  , "pollock"
  , "pompano"
  , "porgy"
  , "Port Jackson shark"
  , "pufferfish"
  , "pupfish"
  , "queen triggerfish"
  , "quillfish"
  , "ray"
  , "remora"
  , "rockfish"
  , "roughy"
  , "sailfish"
  , "salmon"
  , "sardine"
  , "sawfish"
  , "sculpin"
  , "seabass"
  , "seadragon"
  , "seahorse"
  , "shad"
  , "shark"
  , "skate"
  , "smelt"
  , "snapper"
  , "sole"
  , "stingray"
  , "sturgeon"
  , "sunfish"
  , "swordfish"
  , "tarpon"
  , "tetra"
  , "three-spine stickleback"
  , "thresher shark"
  , "tiger shark"
  , "triggerfish"
  , "trout"
  , "tuna"
  , "tunny"
  , "turbot"
  , "upside-down catfish"
  , "velvetfish"
  , "viperfish"
  , "walleye"
  , "whale shark"
  , "whiting"
  , "wrasse"
  , "x-ray tetra"
  , "yellowjack"
  , "yellowtail"
  , "zebra bullhead shark"
  , "zebrafish" ]
  
  // The snake selection geometry
  var SnakeGeometry = function (parent, elements) {
    this._parent = parent;
    this._elements = elements;
    this._k = 0;
  }
  SnakeGeometry.prototype = Object.create(multiselect.DefaultGeometry.prototype);
    SnakeGeometry.prototype.selectionDomain = function(path, J) {  
      if (J === undefined) { J = multiselect.makeEmptyMap(); this._k = 0; } 
      var prev = this._k;
      for (var i = this._k; i < path.length; ++i) {
        for (var j = 0; j < this._elements.length; ++j) {
          if (lineRectIntersect(path[i], path[prev],
                                getOffsetRectangle(this._parent, this._elements[j]))) J.set(j, true);
        }
        prev = i;
      }
      this._k = path.length - 1;
  
      return J;
    }
    SnakeGeometry.prototype.filter = function(p) {   
      var J = multiselect.makeEmptyMap();
      for (var i = 0; i < this._elements.length; ++i) if (p(i)) J.set(i, true);
      return J;
    }
  
  // Helper routines for geometrical calculations
  function lineRectIntersect(p1, p2, r) {
    if (!rectangleIntersect(mkRectangle(p1, p2), r)) return false; // if bounding boxes do not overlap, cannot intersect
    if (pointEquals(p1, p2)) return pointInRectangle(p1, r);
    var p = {};
    if (lineIntersect(p1, p2, { x: r.left, y: r.top }, { x: r.left, y: r.bottom }, p) === 1) return true;
    if (lineIntersect(p1, p2, { x: r.left, y: r.top }, { x: r.right, y: r.top }, p) === 1) return true;
    if (lineIntersect(p1, p2, { x: r.right, y: r.bottom }, { x: r.right, y: r.top }, p) === 1) return true;
    if (lineIntersect(p1, p2, { x: r.right, y: r.bottom }, { x: r.left, y: r.bottom }, p) === 1) return true;
    return pointInRectangle(p1, r) || pointInRectangle(p2, r);
  }
  
  function mkRectangle(p1, p2) {
    return { 
      left: Math.min(p1.x, p2.x),
      top: Math.min(p1.y, p2.y),
      right: Math.max(p1.x, p2.x),
      bottom: Math.max(p1.y, p2.y)
    };        
  }
  
  function pointEquals(p1, p2) { return p1.x === p2.x && p1.y === p2.y; }
    /* PORTED FROM:
  
     * lines_intersect:  AUTHOR: Mukesh Prasad
     *
     *   This function computes whether two line segments,
     *   respectively joining the input points (x1,y1) -- (x2,y2)
     *   and the input points (x3,y3) -- (x4,y4) intersect.
     *   If the lines intersect, the output variables x, y are
     *   set to coordinates of the point of intersection.
     *
     *   All values are in integers.  The returned value is rounded
     *   to the nearest integer point.
     *
     *   If non-integral grid points are relevant, the function
     *   can easily be transformed by substituting floating point
     *   calculations instead of integer calculations.
     *
     *   Entry
     *        x1, y1,  x2, y2   Coordinates of endpoints of one segment.
     *        x3, y3,  x4, y4   Coordinates of endpoints of other segment.
     *
     *   Exit
     *        x, y              Coordinates of intersection point.
     *
     *   The value returned by the function is one of:
     *
     *        DONT_INTERSECT    0
     *        DO_INTERSECT      1
     *        COLLINEAR         2
     *
     * Error conditions:
     *
     *     Depending upon the possible ranges, and particularly on 16-bit
     *     computers, care should be taken to protect from overflow.
     *
     *     In the following code, 'long' values have been used for this
     *     purpose, instead of 'int'.
     *
     */
  
    function sameSigns(a, b) { return a >= 0 && b >= 0 || a < 0 && b < 0; }
  
    function lineIntersect( p1,   /* First line segment */
                            p2,
                            p3,   /* Second line segment */
                            p4,
                            p5    /* Output value:
                                   * point of intersection */
                          )
    {
      const DONT_INTERSECT = 0;
      const DO_INTERSECT = 1;
      const COLLINEAR = 2;
  
      var a1, a2, b1, b2, c1, c2; /* Coefficients of line eqns. */
      var r1, r2, r3, r4;         /* 'Sign' values */
      var denom, offset, num;     /* Intermediate values */
  
      /* Compute a1, b1, c1, where line joining points 1 and 2
       * is "a1 x  +  b1 y  +  c1  =  0".
       */
  
      a1 = p2.y - p1.y;
      b1 = p1.x - p2.x;
      c1 = p2.x * p1.y - p1.x * p2.y;
  
      /* Compute r3 and r4.
       */
      r3 = a1 * p3.x + b1 * p3.y + c1;
      r4 = a1 * p4.x + b1 * p4.y + c1;
  
      /* Check signs of r3 and r4.  If both point 3 and point 4 lie on
       * same side of line 1, the line segments do not intersect.
       */
      if ( r3 != 0 &&
           r4 != 0 &&
           sameSigns( r3, r4 ))
        return ( DONT_INTERSECT );
  
      /* Compute a2, b2, c2 */
      a2 = p4.y - p3.y;
      b2 = p3.x - p4.x;
      c2 = p4.x * p3.y - p3.x * p4.y;
  
      /* Compute r1 and r2 */
      r1 = a2 * p1.x + b2 * p1.y + c2;
      r2 = a2 * p2.x + b2 * p2.y + c2;
  
      /* Check signs of r1 and r2.  If both point 1 and point 2 lie
       * on same side of second line segment, the line segments do
       * not intersect.
       */
      if ( r1 !== 0 &&
           r2 !== 0 &&
           sameSigns( r1, r2 ))
        return ( DONT_INTERSECT );
  
      /* Line segments intersect: compute intersection point. 
       */
  
      denom = a1 * b2 - a2 * b1;
      if ( denom === 0 )
        return ( COLLINEAR );
      // offset = denom < 0 ? - denom / 2 : denom / 2;
  
      // /* The denom/2 is to get rounding instead of truncating.  It
      //  * is added or subtracted to the numerator, depending upon the
      //  * sign of the numerator.
      //  */
  
      // The calculations for p5 are commented out; 
      // we just need to know if lines intersect or not
  
      // num = b1 * c2 - b2 * c1;
      // p5.x = ( num < 0 ? num - offset : num + offset ) / denom;
  
      // num = a2 * c1 - a1 * c2;
      // p5.y = ( num < 0 ? num - offset : num + offset ) / denom;
  
      return DO_INTERSECT;
    } 
  
  // Mouse events
  function setupMouseEvents (parent, canvas, selection) {
  
    function mousedownHandler(evt) {
  
      var mousePos = selection.geometry().m2v(offsetMousePos(parent, evt));
      switch (multiselect.modifierKeys(evt)) {
      case multiselect.NONE: selection.click(mousePos); break;
      case multiselect.CMD: selection.cmdClick(mousePos); break;
      case multiselect.SHIFT: selection.shiftClick(mousePos); break;
      default: return;
      }    
  
      selection.geometry().drawIndicators(selection, canvas, true, true, false);
      document.addEventListener('mousemove', mousemoveHandler, false);
      document.addEventListener('mouseup', mouseupHandler, false);
      evt.preventDefault();
      evt.stopPropagation();
    };
  
    function mousemoveHandler (evt) {
      evt.preventDefault();
      evt.stopPropagation();
      var mousePos = selection.geometry().m2v(offsetMousePos(parent, evt));
      selection.shiftClick(mousePos);
      selection.geometry().drawIndicators(selection, canvas, true, true, true);
    };
  
    function mouseupHandler (evt) {
      document.removeEventListener('mousemove', mousemoveHandler, false);
      document.removeEventListener('mouseup', mouseupHandler, false);
      selection.geometry().drawIndicators(selection, canvas, true, true, false);
    };
  
    parent.addEventListener('mousedown', mousedownHandler, false);
  }
  
  // Keyboard events
    function setupKeyboardEvents(parent, canvas, selection) {
  
      parent.addEventListener('keydown', keydownHandler, false);
      parent.addEventListener('mousedown', function() { parent.focus(); }, false);
  
      function keydownHandler(evt) {
        var handled = false; 
        var mk = multiselect.modifierKeys(evt);
        switch (evt.which) {          
        case 37: handled = callArrow(mk, multiselect.LEFT); break;
        case 38: handled = callArrow(mk, multiselect.UP); break;             
        case 39: handled = callArrow(mk, multiselect.RIGHT); break;
        case 40: handled = callArrow(mk, multiselect.DOWN); break;
        case 32: handled = callSpace(mk); break;
        case 90: handled = callUndoRedo(mk); break;
        default: return; // exit this handler for unrecognized keys
        }
        if (!handled) return; // they key+modifier combination was not recognized
  
        selection.geometry().drawIndicators(selection, canvas, true, true, false);
        evt.preventDefault(); 
        evt.stopPropagation();
      }  
    
      function callUndoRedo (mk) {
        switch (mk) {
        case multiselect.OPT: selection.undo(); break;
        case multiselect.SHIFT_OPT: selection.redo(); break;
        default: return false;
        }      
        return true;
      }
  
      function callArrow (mk, dir) {
        switch (mk) {
        case multiselect.NONE: selection.arrow(dir); break;
        case multiselect.CMD: selection.cmdArrow(dir); break;
        case multiselect.SHIFT: selection.shiftArrow(dir); break;
        default: return false;
        }
        return true;
      }
    
      function callSpace (mk) {
        switch (mk) {
        case multiselect.NONE: selection.space(); break;
        case multiselect.CMD: selection.cmdSpace(); break;
        case multiselect.SHIFT: selection.shiftSpace(); break;
        default: return false;      
        }
        return true;
      }
    }
</script>
<script type="text/javascript">
  $(document).ready(function () {
    // Construct the snake geometry and the selection state object
      var selectableArea3 = $("#selectable_area3")[0];
      for (var i = 0; i<fish.length; ++i) {
        $(selectableArea3).append("<span class='selectable2'>" + fish[i] + "</span> ");
      }
      var selectables3 = $(".selectable2", selectableArea3);    
    var geometry3 = new SnakeGeometry(selectableArea3, selectables3);
    var selection3 = new multiselect.SelectionState(geometry3, mkRefresh(selectables3, 'selected2'), true);
    
    // Add the indicator-drawing function to the geometry
      geometry3.drawIndicators = function (selection, canvas, drawAnchor, drawCursor, drawRubber) {
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (drawAnchor) { 
          ctx.strokeStyle = 'DarkRed';
          var p = multiselect.anchor(selection.selectionPath());
          if (p !== undefined) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI*2, true); 
            ctx.stroke();
          }
        }
        if (drawCursor) { 
          ctx.strokeStyle = 'blue';
          var p = selection.cursor();
          if (p !== undefined) { 
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI*2, true); 
            ctx.stroke();
          }
        }
        if (drawRubber) { 
          ctx.strokeStyle = 'green';
          var path = selection.selectionPath();
          if (path.length > 0) {
            ctx.moveTo(path[0].x, path[0].y);
            for (var i = 1; i < path.length; ++i) ctx.lineTo(path[i].x, path[i].y);
            ctx.stroke();
          }
        }
      }
    
    // setup mouse and keyboard events
      var canvas3 = createCanvas(selectableArea3);
      setupMouseEvents(selectableArea3, canvas3, selection3);
      setupKeyboardEvents(selectableArea3, canvas3, selection3);
    
    // setup the filtering and commit events
      var filter3 = $("#filter3")[0];
    
      $(filter3).keyup(function () {    
        var str = $(filter3).val(); 
        selection3.filter(function(i){ return str !== "" && fish[i].indexOf(str)>-1; });
      });
      $("#commit_filter3").click(function(){ selection3.commit(); });  
  });
</script>

<p>
The HTML code for the selectable area and the filter controls is as follows:
</p>
<div class="org-src-container">

<pre class="src src-js" id="snake-html">&lt;div id=<span style="color: #008000;">"selectable_area3"</span> tabIndex=<span style="color: #008000;">"0"</span>&gt;&lt;/div&gt;&lt;br&gt;
Filter: &lt;input type=<span style="color: #008000;">"text"</span> id=<span style="color: #008000;">"filter3"</span>&gt;&lt;/input&gt;&lt;button id=<span style="color: #008000;">"commit_filter3"</span>&gt;Commit&lt;/button&gt;
</pre>
</div>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Selectable elements</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The selectable elements are again generated by JavaScript. 
The code that populates the <code>fish</code> array is in <a href="fish.js">fish.js</a>.
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-selectables">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectableArea3</span> = $(<span style="color: #008000;">"#selectable_area3"</span>)[0];
  <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span> = 0; i&lt;fish.length; ++i) {
    $(selectableArea3).append(<span style="color: #008000;">"&lt;span class='selectable2'&gt;"</span> + fish[i] + <span style="color: #008000;">"&lt;/span&gt; "</span>);
  }
  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectables3</span> = $(<span style="color: #008000;">".selectable2"</span>, selectableArea3);
</pre>
</div>

<p>
The styles <code>selectable2</code> and <code>selected2</code> are reused from the previous example,
so we only style the selectable area:
</p>

<div class="org-src-container">

<pre class="src src-html" id="snake-css">&lt;<span style="color: #006699;">style</span>&gt; 
  #selectable_area3 { border:1px solid black; cursor:default; } 
&lt;/<span style="color: #006699;">style</span>&gt;
</pre>
</div>



<p>
The snake geometry again stores the DOM object of the
selectable area (<code>parent</code>) and the collection of the
selectable elements (<code>elements</code>). The third member <code>k</code>
is explained below.
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Selection geometry</h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">

<pre class="src src-js" id="snake-geometry"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">SnakeGeometry</span> = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">elements</span>) {
  <span style="color: #8b1a1a;">this</span>._parent = parent;
  <span style="color: #8b1a1a;">this</span>._elements = elements;
  <span style="color: #8b1a1a;">this</span>._k = 0;
}
SnakeGeometry.<span style="color: #8b1a1a;">prototype</span> = Object.create(multiselect.DefaultGeometry.<span style="color: #8b1a1a;">prototype</span>);
</pre>
</div>

<p>
The snake geometry can use the default definitions of <code>m2v</code> (identity)
and <code>extendPath</code> (pushes a new point to the array that represents the selection path).
The <code>selectionDomain</code> function is more complex.
It iterates over all line segments defined by two adjacent points
on the selection path, and for each line segment finds the elements that
the line segment intersects with, and adds them to the selection 
domain. This is quite a bit of work, and thus the 
function implements an optimization. When it is finished
computing a selection domain, it stores the last index of the selection
path in <code>this._k</code>. When <code>shiftClick</code> (which is called repeatedly during rubber band
selection) makes a call to <code>selectionDomain</code>, the call includes the previously calculated
selection domain (<code>J</code>) as the third parameter.
It then suffices to iterate the line segments on the path from the index <code>k</code> 
onward.
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-selection-domain">  SnakeGeometry.<span style="color: #8b1a1a;">prototype</span>.selectionDomain = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">path</span>, <span style="color: #BA36A5;">J</span>) {  
    <span style="color: #0000FF;">if</span> (J === <span style="color: #8b1a1a;">undefined</span>) { J = multiselect.makeEmptyMap(); <span style="color: #8b1a1a;">this</span>._k = 0; } 
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">prev</span> = <span style="color: #8b1a1a;">this</span>._k;
    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span> = <span style="color: #8b1a1a;">this</span>._k; i &lt; path.length; ++i) {
      <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">j</span> = 0; j &lt; <span style="color: #8b1a1a;">this</span>._elements.length; ++j) {
        <span style="color: #0000FF;">if</span> (lineRectIntersect(path[i], path[prev],
                              getOffsetRectangle(<span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements[j]))) J.set(j, <span style="color: #8b1a1a;">true</span>);
      }
      prev = i;
    }
    <span style="color: #8b1a1a;">this</span>._k = path.length - 1;

    <span style="color: #0000FF;">return</span> J;
  }
</pre>
</div>

<p>
A few helper functions are needed. 
The <code>lineRectIntersect</code> function determines if a line intersects with a rectangle,
<code>mkRectangle</code> constructs a rectangle from two points:
</p>

<div class="org-src-container">

<pre class="src src-js" id="line-rect-intersect"><span style="color: #0000FF;">function</span> <span style="color: #006699;">lineRectIntersect</span>(<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span>, <span style="color: #BA36A5;">r</span>) {
  <span style="color: #0000FF;">if</span> (!rectangleIntersect(mkRectangle(p1, p2), r)) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">false</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">if bounding boxes do not overlap, cannot intersect</span>
  <span style="color: #0000FF;">if</span> (pointEquals(p1, p2)) <span style="color: #0000FF;">return</span> pointInRectangle(p1, r);
  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = {};
  <span style="color: #0000FF;">if</span> (lineIntersect(p1, p2, { x: r.left, y: r.top }, { x: r.left, y: r.bottom }, p) === 1) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
  <span style="color: #0000FF;">if</span> (lineIntersect(p1, p2, { x: r.left, y: r.top }, { x: r.right, y: r.top }, p) === 1) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
  <span style="color: #0000FF;">if</span> (lineIntersect(p1, p2, { x: r.right, y: r.bottom }, { x: r.right, y: r.top }, p) === 1) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
  <span style="color: #0000FF;">if</span> (lineIntersect(p1, p2, { x: r.right, y: r.bottom }, { x: r.left, y: r.bottom }, p) === 1) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
  <span style="color: #0000FF;">return</span> pointInRectangle(p1, r) || pointInRectangle(p2, r);
}

<span style="color: #0000FF;">function</span> <span style="color: #006699;">mkRectangle</span>(<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span>) {
  <span style="color: #0000FF;">return</span> { 
    left: Math.min(p1.x, p2.x),
    top: Math.min(p1.y, p2.y),
    right: Math.max(p1.x, p2.x),
    bottom: Math.max(p1.y, p2.y)
  };        
}

<span style="color: #0000FF;">function</span> <span style="color: #006699;">pointEquals</span>(<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span>) { <span style="color: #0000FF;">return</span> p1.x === p2.x &amp;&amp; p1.y === p2.y; }
</pre>
</div>

<p>
The <code>lineIntersect</code> function is more involved.
The code is a bit long, so we show it at the very end of this document 
in Section <a href="#sec-line-intersection-code">4.6</a>.
</p>

<p>
This example allows selecting elements by specifying a predicate.
For this, we must override the <code>filter</code> method. 
It takes a predicate <code>p</code> and returns a <code>Map</code> of all indices for which
the predicate is <code>true</code>.
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Constructing the selection state object</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Constructing the selection state object is as before. 
We again create the refresh callback function with the <code>mkRefresh</code> factory
function, and we set track changes to <code>true</code>. 
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-create-selection-state"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">geometry3</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">SnakeGeometry</span>(selectableArea3, selectables3);
<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selection3</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">multiselect.SelectionState</span>(geometry3, mkRefresh(selectables3, <span style="color: #008000;">'selected2'</span>), <span style="color: #8b1a1a;">true</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Visualizing anchor, cursor, and rubber band</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Drawing the various indicators is done as before.
We again setup a canvas over the selectable area, and add 
the <code>drawIndicators</code> method to the selection geometry object.
The anchor and cursor are drawn as small circles, 
the rubber band indicator as the line segments of
the selection path.
</p>


<div class="org-src-container">

<pre class="src src-js" id="snake-draw-indicators">  geometry3.drawIndicators = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">selection</span>, <span style="color: #BA36A5;">canvas</span>, <span style="color: #BA36A5;">drawAnchor</span>, <span style="color: #BA36A5;">drawCursor</span>, <span style="color: #BA36A5;">drawRubber</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">ctx</span> = canvas.getContext(<span style="color: #008000;">'2d'</span>);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    <span style="color: #0000FF;">if</span> (drawAnchor) { 
      ctx.strokeStyle = <span style="color: #008000;">'DarkRed'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = multiselect.anchor(selection.selectionPath());
      <span style="color: #0000FF;">if</span> (p !== <span style="color: #8b1a1a;">undefined</span>) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2, <span style="color: #8b1a1a;">true</span>); 
        ctx.stroke();
      }
    }
    <span style="color: #0000FF;">if</span> (drawCursor) { 
      ctx.strokeStyle = <span style="color: #008000;">'blue'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = selection.cursor();
      <span style="color: #0000FF;">if</span> (p !== <span style="color: #8b1a1a;">undefined</span>) { 
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2, <span style="color: #8b1a1a;">true</span>); 
        ctx.stroke();
      }
    }
    <span style="color: #0000FF;">if</span> (drawRubber) { 
      ctx.strokeStyle = <span style="color: #008000;">'green'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">path</span> = selection.selectionPath();
      <span style="color: #0000FF;">if</span> (path.length &gt; 0) {
        ctx.moveTo(path[0].x, path[0].y);
        <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span> = 1; i &lt; path.length; ++i) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();
      }
    }
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> Setting up mouse events</h3>
<div class="outline-text-3" id="text-4-5">
<p>
This example reuses the <code>createCanvas</code>, <code>setupMouseEvents</code>, and <code>setupKeyboardEvents</code> functions 
from before for setting up the mouse and keyboard events.
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-setup-mouse-events">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">canvas3</span> = createCanvas(selectableArea3);
  setupMouseEvents(selectableArea3, canvas3, selection3);
  setupKeyboardEvents(selectableArea3, canvas3, selection3);
</pre>
</div>

<p>
The <i>Filter</i> textbox also listens to keyboard events. When its
contents change, a new predicate is built and the <code>SelectionState</code> object&rsquo;s
<code>filter</code> method is invoked. The predicate is true for some element
if the contents of the textbox is a substring of that element&rsquo;s string value.
To be able to commit the result of filtering as 
an undoable state, we bind the <i>Commit</i> button&rsquo;s click to the <code>commit</code> method.
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-setup-filter-events">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">filter3</span> = $(<span style="color: #008000;">"#filter3"</span>)[0];

  $(filter3).keyup(<span style="color: #0000FF;">function</span> () {    
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">str</span> = $(filter3).val(); 
    selection3.filter(<span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">i</span>){ <span style="color: #0000FF;">return</span> str !== <span style="color: #008000;">""</span> &amp;&amp; fish[i].indexOf(str)&gt;-1; });
  });
  $(<span style="color: #008000;">"#commit_filter3"</span>).click(<span style="color: #0000FF;">function</span>(){ selection3.commit(); });
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-line-intersection-code" class="outline-3">
<h3 id="sec-line-intersection-code"><a id="sec-4-6"></a><span class="section-number-3">4.6</span> Line intersection code</h3>
<div class="outline-text-3" id="text-sec-line-intersection-code">
<p>
This function is adapted from Prasad Mukesh&rsquo;s C-code <i>Intersection of Line Segments</i>, 
ACM Transaction of Graphics&rsquo; Graphics Gems II, p. 7&#x2013;9, code: p. 473&#x2013;476, <code>xlines.c</code>.
</p>

<div class="org-src-container">

<pre class="src src-js" id="line-intersect">  <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">PORTED FROM:</span>

<span style="color: #8D8D84; font-style: italic;">   * lines_intersect:  AUTHOR: Mukesh Prasad</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   This function computes whether two line segments,</span>
<span style="color: #8D8D84; font-style: italic;">   *   respectively joining the input points (x1,y1) -- (x2,y2)</span>
<span style="color: #8D8D84; font-style: italic;">   *   and the input points (x3,y3) -- (x4,y4) intersect.</span>
<span style="color: #8D8D84; font-style: italic;">   *   If the lines intersect, the output variables x, y are</span>
<span style="color: #8D8D84; font-style: italic;">   *   set to coordinates of the point of intersection.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   All values are in integers.  The returned value is rounded</span>
<span style="color: #8D8D84; font-style: italic;">   *   to the nearest integer point.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   If non-integral grid points are relevant, the function</span>
<span style="color: #8D8D84; font-style: italic;">   *   can easily be transformed by substituting floating point</span>
<span style="color: #8D8D84; font-style: italic;">   *   calculations instead of integer calculations.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   Entry</span>
<span style="color: #8D8D84; font-style: italic;">   *        x1, y1,  x2, y2   Coordinates of endpoints of one segment.</span>
<span style="color: #8D8D84; font-style: italic;">   *        x3, y3,  x4, y4   Coordinates of endpoints of other segment.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   Exit</span>
<span style="color: #8D8D84; font-style: italic;">   *        x, y              Coordinates of intersection point.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   The value returned by the function is one of:</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *        DONT_INTERSECT    0</span>
<span style="color: #8D8D84; font-style: italic;">   *        DO_INTERSECT      1</span>
<span style="color: #8D8D84; font-style: italic;">   *        COLLINEAR         2</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   * Error conditions:</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *     Depending upon the possible ranges, and particularly on 16-bit</span>
<span style="color: #8D8D84; font-style: italic;">   *     computers, care should be taken to protect from overflow.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *     In the following code, 'long' values have been used for this</span>
<span style="color: #8D8D84; font-style: italic;">   *     purpose, instead of 'int'.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   */</span>

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">sameSigns</span>(<span style="color: #BA36A5;">a</span>, <span style="color: #BA36A5;">b</span>) { <span style="color: #0000FF;">return</span> a &gt;= 0 &amp;&amp; b &gt;= 0 || a &lt; 0 &amp;&amp; b &lt; 0; }

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">lineIntersect</span>( <span style="color: #BA36A5;">p1</span>,   <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">First line segment */</span>
                          <span style="color: #BA36A5;">p2</span>,
                          <span style="color: #BA36A5;">p3</span>,   <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Second line segment */</span>
                          <span style="color: #BA36A5;">p4</span>,
                          p5    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Output value:</span>
<span style="color: #8D8D84; font-style: italic;">                                 * point of intersection */</span>
                        )
  {
    <span style="color: #0000FF;">const</span> <span style="color: #BA36A5;">DONT_INTERSECT</span> = 0;
    <span style="color: #0000FF;">const</span> <span style="color: #BA36A5;">DO_INTERSECT</span> = 1;
    <span style="color: #0000FF;">const</span> <span style="color: #BA36A5;">COLLINEAR</span> = 2;

    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">a1</span>, <span style="color: #BA36A5;">a2</span>, <span style="color: #BA36A5;">b1</span>, <span style="color: #BA36A5;">b2</span>, <span style="color: #BA36A5;">c1</span>, <span style="color: #BA36A5;">c2</span>; <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Coefficients of line eqns. */</span>
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r1</span>, <span style="color: #BA36A5;">r2</span>, <span style="color: #BA36A5;">r3</span>, <span style="color: #BA36A5;">r4</span>;         <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">'Sign' values */</span>
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">denom</span>, <span style="color: #BA36A5;">offset</span>, <span style="color: #BA36A5;">num</span>;     <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Intermediate values */</span>

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Compute a1, b1, c1, where line joining points 1 and 2</span>
<span style="color: #8D8D84; font-style: italic;">     * is "a1 x  +  b1 y  +  c1  =  0".</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>

    a1 = p2.y - p1.y;
    b1 = p1.x - p2.x;
    c1 = p2.x * p1.y - p1.x * p2.y;

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Compute r3 and r4.</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>
    r3 = a1 * p3.x + b1 * p3.y + c1;
    r4 = a1 * p4.x + b1 * p4.y + c1;

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Check signs of r3 and r4.  If both point 3 and point 4 lie on</span>
<span style="color: #8D8D84; font-style: italic;">     * same side of line 1, the line segments do not intersect.</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>
    <span style="color: #0000FF;">if</span> ( r3 != 0 &amp;&amp;
         r4 != 0 &amp;&amp;
         sameSigns( r3, r4 ))
      <span style="color: #0000FF;">return</span> ( DONT_INTERSECT );

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Compute a2, b2, c2 */</span>
    a2 = p4.y - p3.y;
    b2 = p3.x - p4.x;
    c2 = p4.x * p3.y - p3.x * p4.y;

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Compute r1 and r2 */</span>
    r1 = a2 * p1.x + b2 * p1.y + c2;
    r2 = a2 * p2.x + b2 * p2.y + c2;

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Check signs of r1 and r2.  If both point 1 and point 2 lie</span>
<span style="color: #8D8D84; font-style: italic;">     * on same side of second line segment, the line segments do</span>
<span style="color: #8D8D84; font-style: italic;">     * not intersect.</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>
    <span style="color: #0000FF;">if</span> ( r1 !== 0 &amp;&amp;
         r2 !== 0 &amp;&amp;
         sameSigns( r1, r2 ))
      <span style="color: #0000FF;">return</span> ( DONT_INTERSECT );

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Line segments intersect: compute intersection point. </span>
<span style="color: #8D8D84; font-style: italic;">     */</span>

    denom = a1 * b2 - a2 * b1;
    <span style="color: #0000FF;">if</span> ( denom === 0 )
      <span style="color: #0000FF;">return</span> ( COLLINEAR );
    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">offset = denom &lt; 0 ? - denom / 2 : denom / 2;</span>

    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">/* The denom/2 is to get rounding instead of truncating.  It</span>
    <span style="color: #8D8D84;">//  </span><span style="color: #8D8D84; font-style: italic;">* is added or subtracted to the numerator, depending upon the</span>
    <span style="color: #8D8D84;">//  </span><span style="color: #8D8D84; font-style: italic;">* sign of the numerator.</span>
    <span style="color: #8D8D84;">//  </span><span style="color: #8D8D84; font-style: italic;">*/</span>

    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">The calculations for p5 are commented out; </span>
    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">we just need to know if lines intersect or not</span>

    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">num = b1 * c2 - b2 * c1;</span>
    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">p5.x = ( num &lt; 0 ? num - offset : num + offset ) / denom;</span>

    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">num = a2 * c1 - a1 * c2;</span>
    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">p5.y = ( num &lt; 0 ? num - offset : num + offset ) / denom;</span>

    <span style="color: #0000FF;">return</span> DO_INTERSECT;
  }
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
Command-click in Macs correspond to control-click in Windows. Other
computers or operating systems might use still different modifier keys.
</p></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<code>Map</code> is part of the draft ECMAScript 6 standard, see
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map</a>.
It is supported by all major browsers.
</p></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
By <i>class</i> we mean an object that emulates a class 
following popular JavaScript idioms.
</p></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
The first example&rsquo;s selection geometry is also such that
only the anchor and active end matter in computing the selection domain.
To avoid storing unused points in the path arrays,
we could have redefined <code>extendPath</code> to 
discard the intermediate points there too.
</p></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <p class="footpara">
Perhaps &ldquo;lasso&rdquo; selection, where the user draws a path around
the elements to be selected, is a more common freehand selection
mechanism. Identifying the elements that intersect with an arbitrary
polygon is, however, quite a bit more complex than identifying
elements that intersect with a path.  For this tutorial, we choose to
implement the less complex selection mechanism. 
</p></div>


</div>
</div></div>
</body>
</html>
