<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>MultiselectJS Tutorial</title>
<!-- 2015-08-21 Fri 22:38 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Jaakko JÃ¤rvi" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<style>body { font-family: Arial, Verdana, Helvetica, sans-serif; }</style>
<style>.org-src-name { font-weight: normal; text-decoration: overline underline;  font-family: monospace; margin-top: 1cm; }</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">MultiselectJS Tutorial</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a>
<ul>
<li><a href="#sec-1-1">1.1. Concepts</a></li>
<li><a href="#sec-1-2">1.2. The meaning of click, command-click, and shift-click</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Example: selecting from an ordered list of non-overlapping elements</a>
<ul>
<li><a href="#sec-2-1">2.1. Imports</a></li>
<li><a href="#sec-2-2">2.2. Selectable elements</a></li>
<li><a href="#sec-2-3">2.3. Visualizing the selection state</a></li>
<li><a href="#sec-2-4">2.4. Selection geometry</a></li>
<li><a href="#sec-2-5">2.5. Selection state object</a></li>
<li><a href="#sec-2-6">2.6. Setting up mouse events</a></li>
<li><a href="#sec-show-selected">2.7. Accessing selected elements</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Example: selection geometry that is both row-wise ordered and rectangular</a>
<ul>
<li><a href="#sec-3-1">3.1. Selectable elements</a></li>
<li><a href="#sec-refreshing-and-tracking">3.2. Refreshing</a></li>
<li><a href="#sec-3-3">3.3. Selection geometry</a></li>
<li><a href="#sec-create-selection-state-2">3.4. Selection state object</a></li>
<li><a href="#sec-3-5">3.5. Mouse events</a></li>
<li><a href="#sec-3-6">3.6. Keyboard events</a></li>
<li><a href="#sec-path-visualization">3.7. Visualizing anchor, cursor, and rubberband</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Example: snake selection geometry</a>
<ul>
<li><a href="#sec-4-1">4.1. Draw indicators</a></li>
<li><a href="#sec-4-2">4.2. Setting up mouse events</a></li>
<li><a href="#sec-line-intersection-code">4.3. Line intersection code</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
MultiselectJS is a library for implementing <i>multi-selection</i>, i.e., the
feature supporting selectitng and deselecting elements from a
collection using the mouse (or another pointing device) or a
keyboard. The visual aspects of selection, the shape and location of
elements, their ordering, indicators of selection status, etc. vary
from one application to another. These are the aspects that the client
defines, MultiselectJS implements the rest.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Concepts</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The multi-selection task is to idenfity a subset of a
collection of elements.  To abstract over what these elements are (DOM
elements, characters in text, polygons drawn on a canvas, etc.), we
assume that each element is uniquely identified by some
<i>index</i>. Indices can be of any type that can be compared for equality
with <code>===</code>, such as numbers, object references, or strings.
</p>

<p>
The selection state of elements is modeled as a function from indices
to booleans, where <code>true</code> indicates that an element is selected,
<code>false</code> that it is not.  We call such a function a <i>selection
mapping</i>.  User&rsquo;s selection actions, such as clicking the mouse on an
element, dragging a ``rubber band&rsquo;&rsquo; around elements, or pressing an
arrow key with the shift modifier key held down translate to one or
more <i>selection operations</i> that modify the selection mapping.
</p>

<p>
Each selection operation is associated with a <i>selection domain</i> that
determines the set of indices that the operation affects, and a
<i>selection function</i> that determines whether the indices will be
selected, deselected, or toggled.  The user indicates the selection
domain through specifying a <i>selection path</i>, a sequence of points in
some suitable coordinate space. This <i>selection space</i> could be, for
example, the mouse locations in a window or pairs of row and column
indices in a grid of elements.  The first point of a selection path
arises from a click or a command-click<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>, the subsequent points
from shift-clicks (or mouse moves, when rubber band selecting).  The
first point is called the <i>anchor</i> and the last the <i>active end</i> of
the path. In the case of a one-element path, the anchor and active end
coincide. The selection domain specified by the current selection path
is the <i>active</i> selection domain.
</p>

<p>
Figure <a href="#fig-selection-concepts-results">1</a> shows concrete instances of the
above concepts. The selectable elements are rectangles of arbitrary
size, they are placed in arbitrary locations, and they can overlap. We
make the following observations:
</p>

<ul class="org-ul">
<li>The selected elements are items 2, 4, 5, and 6, and hence the
selection mapping maps the indices 2, 4, 5, and 6 to <code>true</code>, and all
other indices to <code>false</code>.</li>
<li>The element 4 has been selected with a prior selection command.
To select the elements 2, 5, and 6, the user has clicked the
location marked with a red circle, and then dragged the mouse
(<i>rubber band selection</i>) through several other locations (small
blue dots). The last (or current) mouse location is marked with
the blue circle.</li>
<li>The selection space coincides with the space of mouse coordinates.
The sequence of points indicated by the blue dots therefore
constitute the selection path.</li>
<li>In most selection contexts, the anchor and active end are the only
points that matter in determining the selection domain. Here, the
anchor and active end serve as the opposite cornerns of a
rectangle&#x2014;all elements that overlap with this rectangle (shown
in blue) belong to the active selection domain.</li>
</ul>


<div id="fig-selection-concepts-results" class="figure">
<p><img src="selection_concepts.png" alt="selection_concepts.png" />
</p>
<p><span class="figure-number">Figure 1:</span> A snapshot of a selection interaction. The selection path (the blue points) give rise to the selection domain consisting of the items 2, 5 and 6.</p>
</div>

<p>
How the selection path determines the selection domain varies from one
context to another. This variation is captured in the <i>selection
geometry</i>.  Concretely, a selection geometry in MultiselectJS is an
object that defines the functions:
</p>

<ul class="org-ul">
<li><code>m2v(point)</code> that converts mouse coordinates to selection space
coordinates;</li>
<li><code>selectionDomain(path, cmdType, J)</code> that maps a selection <code>path</code>
to a selection domain (the <code>cmdType</code> and <code>J</code> parameters are to
enable optimizations, and they are explained later);</li>
<li><code>extendPath(path, point)</code> that defines how a new point is added to
the selection path;</li>
<li><code>filter(pred)</code> that computes a selection domain as the set of
indices that satisfy the predicate <code>pred</code>;</li>
<li><code>step(direction, point)</code> that defines how arrow keys should impact
the current <i>keyboard cursor</i> location; and</li>
<li><code>defaultCursor(direction)</code> that defines default cursor locations
for when no operations have yet been performed.</li>
</ul>

<p>
The library has default definitions for each of the selection
geometry&rsquo;s functions, and often it suffices to implement only a subset
of them. For example, in the selection geometry of Figure
<a href="#fig-selection-concepts-results">1</a>, the default definitions for <code>m2v</code>
(identity function) and <code>extendPath</code> (add point as the new anchor) can
be used.  If the example does not support keyboard selection, <code>step</code>
and <code>defaultCursor</code> need not be defined.  If it does not support
selection by a predicate, <code>filter</code> need not be defined.  The only
function that must be defined is <code>selectionDomain</code>; it computes the
set of elements that overlaps with the rectangle indicated by two
points, the anchor and active end.
</p>


<div id="fig-simple-selection-geometry-results" class="figure">
<p><img src="simple-selection-geometry.png" alt="simple-selection-geometry.png" />
</p>
<p><span class="figure-number">Figure 2:</span> The selection path is the sequence 5, 2. The anchor is 5 and the active end 2. The selection domain is the set {2, 3, 4, 5}.</p>
</div>

<p>
Figure <a href="#fig-simple-selection-geometry-results">2</a> shows a snapshot from a
selection context that has a different selection geometry.  In this
geometry, the selection space coincides with the set of element
indices: the <code>m2v</code> function maps all mouse positions that fall within
an element&rsquo;s extents to the index of that element.  In this context,
elements are considered to be ordered, so the <code>selectionDomain</code>
function maps a selection path to the range of indices between
(inclusive) the path&rsquo;s anchor and active end. The anchor is marked
with a red dashed frame and the active end with blue.  Here, the user
has clicked first somewhere on <code>Item 5</code> and then shift-clicked
somewhere on <code>Item 2</code>.  As a result, all elements between these two
items are marked selected.
</p>


<p>
Another aspect that varies from one selection context to another is if
and how the anchor and the active end, and more generally the
selection path, are visualized.  MultiselectJS leaves these questions to
the client, but makes the data needed for those visualizations readily
available (see Section <a href="#sec-path-visualization">3.7</a>).
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> The meaning of click, command-click, and shift-click</h3>
<div class="outline-text-3" id="text-1-2">
<p>
<i>Click</i>, <i>command-click</i>, and <i>shift-click</i> are the basic selection
tools that most applications support. Different applications assign
slightly different meanings to these operations. The key bindings may
vary as well (e.g., Windows&rsquo; <i>ctrl-click</i> corresponds to OS X&rsquo;s
command-click).  These three commands are the basic building blocks of
MultiselectJS, in terms of which most other (keyboard and rubber band
selection) commands are defined.  In a nutshell, the three selection
commands work as follows:
</p>

<ul class="org-ul">
<li>Click commits the current selection as an undoable state, deselects
all selected elements, clears the selection path, establishes a new
selection path that consists solely of the anchor, and sets the
selection function to <i>select</i>. It then computes the selection
domain that corresponds to the single-element selection path and
selects the element(s) in the selection domain, which becomes the
new active selection domain.</li>

<li>Command-click commits the current selection as an undoable state,
clears the selection path, and establishes a new selection path that
consists solely of the anchor. If the anchor is on an already
selected element, the selection function is set to <i>deselect</i>,
otherwise to <i>select</i>. It then computes the selection domain that
corresponds to the single element selection path and selects or
deselects the element(s) in the selection domain, which becomes the
new active selection domain.</li>

<li>Shift-click extends the current selection path by a new point, and
computes a selection domain that corresponds to this new selection
path. This selection domain replaces the current active selection
domain, so it cancels the effect of the previous one selection
operation, and applies the same selection function to a new domain.</li>
</ul>

<p>
MultiselectJS does not insist on particular key bindings for any of the
selection operations, but the naming of the functions in its public
API reflects our recommendations.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Example: selecting from an ordered list of non-overlapping elements</h2>
<div class="outline-text-2" id="text-2">
<p>
The first example is a horizontal list of elements, in which elements
can be selected using the click, command-click, and shift-click
commands.  The <i>Show animals</i> button displays a list of currently
selected elements.
</p>

<script type="text/javascript" src="../../dist/multiselect.js"></script>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <style>
    .selectable { outline:1px solid; padding:10px; cursor:default; }
    .selected { background-color: khaki; }
  </style>
<script type="text/javascript">
     // helper functions to deal with points, rectangles, etc.
       function pointInRectangle(mp, r) {
         return mp.x >= r.left && mp.x <= r.right && 
                mp.y >= r.top && mp.y <= r.bottom;
       }
   
     // determine which modifier keys were held down during event
     const M_NONE = 1, 
           M_SHIFT = 2, 
           M_CMD = 3, 
           M_SHIFT_CMD = 4, 
           M_OPT = 5, 
           M_SHIFT_OPT = 6;
     
     function modifierKeys (evt) {
       
       if (evt.shiftKey && isCmdKey(evt)) return M_SHIFT_CMD;
       if (isCmdKey(evt)) return M_CMD;
       if (evt.shiftKey && evt.altKey) return M_SHIFT_OPT;
       if (evt.altKey) return M_OPT;
       if (evt.shiftKey) return M_SHIFT;
       return M_NONE;
     
       function isCmdKey (evt) { return evt.metaKey || evt.ctrlKey; }
     }
   
     // OrderedList selection geometry
     var OrderedGeometry = function (elements) {
       this._elements = elements;
     }
     OrderedGeometry.prototype = Object.create(multiselect.DefaultGeometry.prototype);
       OrderedGeometry.prototype.m2v = function(mp) {
         for (var i=0; i<this._elements.length; ++i) {
           if (pointInRectangle(mp, this._elements[i].getBoundingClientRect())) return i;
         }
       }
       OrderedGeometry.prototype.selectionDomain = function(path) {
         var J = multiselect.makeEmptyMap();
         var a = multiselect.anchor(path);
         var b = multiselect.activeEnd(path);
         for (var i=Math.min(a, b); i<=Math.max(a, b); ++i) J.set(i, true);
         return J;
       }

   document.addEventListener("DOMContentLoaded", function() { 
      // selectable elements
      var selectableArea = document.getElementById("selectable_area");
      var selectables = selectableArea.getElementsByClassName("selectable");
      
      // the refresh function
        function refresh(s) {
          for(var i=0; i<selectables.length; ++i) { 
            selectables[i].classList.toggle('selected', s(i));
          };
        }  
      
      // create the selection object
        var geometry = new OrderedGeometry(selectables);
        var selection = new multiselect.SelectionState(geometry, refresh, false, 10);
      
      // register mouse events
        function mousedownHandler(evt) {
          evt.preventDefault();
          evt.stopPropagation();
      
          var vp = selection.geometry().m2v({ x: evt.clientX, y: evt.clientY });
      
          switch (modifierKeys(evt)) {
          case M_NONE: selection.click(vp); break;
          case M_CMD: selection.cmdClick(vp); break;
          case M_SHIFT: selection.shiftClick(vp); break;
          }
        };
      
        selectableArea.addEventListener('mousedown', mousedownHandler, false);
      
      // find out which elements are selected
        function showAnimals() {
          var s = "";
          selection.selected().forEach(function(v) { 
            s = s + selectables[v].textContent + " "; 
          });
          document.getElementById("animal_list").textContent = s; 
        }
        document.getElementById("show_animals").addEventListener("click", showAnimals);
   });
</script>
    <table id="selectable_area">
      <tr><td class="selectable">pig</td>
      <td class="selectable">cow</td>             
      <td class="selectable">goat</td>
      <td class="selectable">horse</td>
      <td class="selectable">sheep</td>
      <td class="selectable">chicken</td>
      <td class="selectable">duck</td>
      <td class="selectable">turkey</td>
      <td class="selectable">ostrich</td>
      <td class="selectable">mule</td>
      </tr>
    </table>

    <br>
    <button id="show_animals">Show selected animals</button> <span id="animal_list"></span>

<p target="_blank">
The <a href="example-1.html" target="_blank">example</a> and its <a href="example-1-source.html">complete source code</a> can be viewed in separate windows.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Imports</h3>
<div class="outline-text-3" id="text-2-1">
<p>
To use MultiselectJS on a page is a matter of importing it as a script. 
There are no dependencies.
</p>

<div class="org-src-container">

<pre class="src src-html" id="js-imports">&lt;<span style="color: #006699;">script</span> <span style="color: #BA36A5;">type</span>=<span style="color: #008000;">"text/javascript"</span> <span style="color: #BA36A5;">src</span>=<span style="color: #008000;">"../../dist/multiselect.js"</span>&gt;&lt;/<span style="color: #006699;">script</span>&gt;
&lt;<span style="color: #006699;">script</span> <span style="color: #BA36A5;">type</span>=<span style="color: #008000;">"text/javascript"</span> <span style="color: #BA36A5;">src</span>=<span style="color: #008000;">"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"</span>&gt;&lt;/<span style="color: #006699;">script</span>&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Selectable elements</h3>
<div class="outline-text-3" id="text-2-2">
<p>
In this example, the selectable elements are HTML table cells.  We
give the cells the <code>selectable</code> class attribute so that they are
easily accessible. The <code>animal_list</code> span is a placeholder for where
the selected animal names will be shown when the <code>show_animals</code> button
is clicked.
</p>

<div class="org-src-container">

<pre class="src src-html" id="ordered-list-html">    &lt;<span style="color: #006699;">table</span> <span style="color: #BA36A5;">id</span>=<span style="color: #008000;">"selectable_area"</span>&gt;
      &lt;<span style="color: #006699;">tr</span>&gt;&lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;pig&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;cow&lt;/<span style="color: #006699;">td</span>&gt;             
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;goat&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;horse&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;sheep&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;chicken&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;duck&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;turkey&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;ostrich&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;<span style="color: #006699;">td</span> <span style="color: #BA36A5;">class</span>=<span style="color: #008000;">"selectable"</span>&gt;mule&lt;/<span style="color: #006699;">td</span>&gt;
      &lt;/<span style="color: #006699;">tr</span>&gt;
    &lt;/<span style="color: #006699;">table</span>&gt;

    &lt;<span style="color: #006699;">br</span>&gt;
    &lt;<span style="color: #006699;">button</span> <span style="color: #BA36A5;">id</span>=<span style="color: #008000;">"show_animals"</span>&gt;Show selected animals&lt;/<span style="color: #006699;">button</span>&gt; &lt;<span style="color: #006699;">span</span> <span style="color: #BA36A5;">id</span>=<span style="color: #008000;">"animal_list"</span>&gt;&lt;/<span style="color: #006699;">span</span>&gt;
</pre>
</div>

<p>
Next, we access the above HTML elements from JavaScript code:
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-list-selectables"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectableArea</span> = document.getElementById(<span style="color: #008000;">"selectable_area"</span>);
<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectables</span> = selectableArea.getElementsByClassName(<span style="color: #008000;">"selectable"</span>);
</pre>
</div>

<p>
The <code>selectableArea</code> object is the target of the mouse events.
The <code>selectables</code> objects is the collection of the selectable elements;
it is an &ldquo;array-like&rdquo; object, indexed with integers.
</p>
</div>
</div>


<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Visualizing the selection state</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The following CSS code defines the visual appearance of selectable
elements in both their unselected and selected states.
The <code>.selected</code> class is turned on when an element is selected and off
when deselected.
</p>

<div class="org-src-container">

<pre class="src src-html" id="ordered-list-css">  &lt;<span style="color: #006699;">style</span>&gt;
    .selectable { outline:1px solid; padding:10px; cursor:default; }
    .selected { background-color: khaki; }
  &lt;/<span style="color: #006699;">style</span>&gt;
</pre>
</div>

<p>
To enable displaying the current selection state, MultiselectJS invokes a
callback function after every selection command (unless the library
recognizes that a command had no effect).  The callback&rsquo;s parameter,
<code>s</code>, is the current selection mapping.  Here, the callback iterates
over all selectable elements and toggles the <code>selected</code> class
attribute according to each element&rsquo;s selection status:
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-list-refresh">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">refresh</span>(<span style="color: #BA36A5;">s</span>) {
    <span style="color: #0000FF;">for</span>(<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=0; i&lt;selectables.length; ++i) { 
      selectables[i].classList.toggle(<span style="color: #008000;">'selected'</span>, s(i));
    };
  }
</pre>
</div>

<p>
The library can also be configured to <i>track changes</i>, in which case
the argument to the callback would be a <code>Map</code><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> of changed
elements. This mechanism is explained in Section
<a href="#sec-refreshing-and-tracking">3.2</a>.
</p>
</div>
</div>


<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Selection geometry</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The <code>OrderedGeometry</code> class is the selection geometry for our example.
It stores a reference to the collection of the selectable elements.
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-geometry"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">OrderedGeometry</span> = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">elements</span>) {
  <span style="color: #8b1a1a;">this</span>._elements = elements;
}
OrderedGeometry.<span style="color: #8b1a1a;">prototype</span> = Object.create(multiselect.DefaultGeometry.<span style="color: #8b1a1a;">prototype</span>);
</pre>
</div>

<p>
<code>OrderedGeometry</code> inherits from <code>DefaultGeometry</code> to get the default
implementations of the selection geometry methods.  The superclass&rsquo;
constructor is not called since the base class has no
state. <code>OrderedGeometry</code> defines two methods: <code>m2v</code> and
<code>selectionDomain</code>.
</p>

<p>
The selection space coordinates are the indices of the selectable
elements, integers between <code>0</code> and <code>this._elements.length - 1</code>.  
The <code>m2v</code> function finds the element on which the
mouse coordinate <code>mp</code> falls on and returns the element&rsquo;s index.
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-geometry-m2v">  OrderedGeometry.<span style="color: #8b1a1a;">prototype</span>.m2v = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">mp</span>) {
    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=0; i&lt;<span style="color: #8b1a1a;">this</span>._elements.length; ++i) {
      <span style="color: #0000FF;">if</span> (pointInRectangle(mp, <span style="color: #8b1a1a;">this</span>._elements[i].getBoundingClientRect())) <span style="color: #0000FF;">return</span> i;
    }
  }
</pre>
</div>

<p>
The helper function <code>pointInRectangle</code> checks whether a point is
inside a rectangle. 
</p>

<div class="org-src-container">

<pre class="src src-js" id="point-in-rectangle">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">pointInRectangle</span>(<span style="color: #BA36A5;">mp</span>, <span style="color: #BA36A5;">r</span>) {
    <span style="color: #0000FF;">return</span> mp.x &gt;= r.left &amp;&amp; mp.x &lt;= r.right &amp;&amp; 
           mp.y &gt;= r.top &amp;&amp; mp.y &lt;= r.bottom;
  }
</pre>
</div>

<p>
The <code>selectionDomain</code> function is simple&#x2014;it constructs a new <code>Map</code>
object with <code>makeEmptyMap</code>, extracts the anchor and active end
from the selection path, and sets all indices between them to <code>true</code>:
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-geometry-selection-domain">  OrderedGeometry.<span style="color: #8b1a1a;">prototype</span>.selectionDomain = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">path</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">J</span> = multiselect.makeEmptyMap();
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">a</span> = multiselect.anchor(path);
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">b</span> = multiselect.activeEnd(path);
    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=Math.min(a, b); i&lt;=Math.max(a, b); ++i) J.set(i, <span style="color: #8b1a1a;">true</span>);
    <span style="color: #0000FF;">return</span> J;
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Selection state object</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The <code>SelectionState</code> class maintains all the state of the selection,
including the current selection mapping, selection path, and undo and
redo stacks.  It defines methods for the various selection commands
(<code>click</code>, <code>cmdClick</code>, <code>shiftClick</code> etc.).  The <code>SelectionState</code>
constructor&rsquo;s parameters are a <i>selection geometry</i>, the <i>refresh callback</i>, a
boolean that turns <i>change tracking</i> on or off, and the <i>maximum number
of undo states</i> to remember. The last two can be omitted if their defaults
(<code>false</code> and <code>10</code>, respectively) are suitable.
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-list-create-selection">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">geometry</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">OrderedGeometry</span>(selectables);
  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selection</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">multiselect.SelectionState</span>(geometry, refresh, <span style="color: #8b1a1a;">false</span>, 10);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> Setting up mouse events</h3>
<div class="outline-text-3" id="text-2-6">
<p>
The event handler for the <i>mouse down</i> event recognizes clicks,
command-clicks, and shift-clicks, and invokes the corresponding
library functions. Detecting modifier keys is somewhat messy.  We thus
define constants that indicate shift, command, and option modifiers,
and define a function to translate the browser and OS specific event
data to one of these constants of our own:
</p>

<div class="org-src-container">

<pre class="src src-js" id="modifier-keys"><span style="color: #0000FF;">const</span> <span style="color: #BA36A5;">M_NONE</span> = 1, 
      M_SHIFT = 2, 
      M_CMD = 3, 
      M_SHIFT_CMD = 4, 
      M_OPT = 5, 
      M_SHIFT_OPT = 6;

<span style="color: #0000FF;">function</span> <span style="color: #006699;">modifierKeys</span> (<span style="color: #BA36A5;">evt</span>) {
  
  <span style="color: #0000FF;">if</span> (evt.shiftKey &amp;&amp; isCmdKey(evt)) <span style="color: #0000FF;">return</span> M_SHIFT_CMD;
  <span style="color: #0000FF;">if</span> (isCmdKey(evt)) <span style="color: #0000FF;">return</span> M_CMD;
  <span style="color: #0000FF;">if</span> (evt.shiftKey &amp;&amp; evt.altKey) <span style="color: #0000FF;">return</span> M_SHIFT_OPT;
  <span style="color: #0000FF;">if</span> (evt.altKey) <span style="color: #0000FF;">return</span> M_OPT;
  <span style="color: #0000FF;">if</span> (evt.shiftKey) <span style="color: #0000FF;">return</span> M_SHIFT;
  <span style="color: #0000FF;">return</span> M_NONE;

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">isCmdKey</span> (<span style="color: #BA36A5;">evt</span>) { <span style="color: #0000FF;">return</span> evt.metaKey || evt.ctrlKey; }
}
</pre>
</div>

<p>
The <code>isCmdKey</code> function defines what keys are interpreted as the
command modifier; we accept both control and command keys. This is
because in the context of multiselection the role of the command
modifier under Mac OS X is the same as that of the control modifier
under Windows and Linux. In a production application, one might want
to detect the platform and only accept one of the alternatives,
according to the platform convention. The option modifier (alt in
Windows) is also recognized, with and withouth shift.  This modifier
is used in key bindings of undo and redo commands.
</p>

<p>
The handler for the mouse down event can now be defined and registered:
</p>

<div class="org-src-container">

<pre class="src src-js" id="setup-mouse-events-simple">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">mousedownHandler</span>(<span style="color: #BA36A5;">evt</span>) {
    evt.preventDefault();
    evt.stopPropagation();

    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">vp</span> = selection.geometry().m2v({ x: evt.clientX, y: evt.clientY });

    <span style="color: #0000FF;">switch</span> (modifierKeys(evt)) {
    <span style="color: #0000FF;">case</span> M_NONE: selection.click(vp); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> M_CMD: selection.cmdClick(vp); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> M_SHIFT: selection.shiftClick(vp); <span style="color: #0000FF;">break</span>;
    }
  };

  selectableArea.addEventListener(<span style="color: #008000;">'mousedown'</span>, mousedownHandler, <span style="color: #8b1a1a;">false</span>);
</pre>
</div>

<p>
How selection events are recognized may have to take into account
other mouse events, in particular those for dragging to copy or move
already selected elements. This example ignores such concerns.
Regardless of the precise way of recognizing mouse events, we draw
attention to the simplicity of invoking MultiselectJS&rsquo;s services: the
selection geometry&rsquo;s <code>m2v</code> function transforms the mouse position into
a selection space coordinate, which is passed to either the <code>click</code>,
<code>cmdClick</code>, or <code>shiftClick</code> method.
</p>
</div>
</div>

<div id="outline-container-sec-show-selected" class="outline-3">
<h3 id="sec-show-selected"><a id="sec-2-7"></a><span class="section-number-3">2.7</span> Accessing selected elements</h3>
<div class="outline-text-3" id="text-sec-show-selected">
<p>
The first example is complete, except for handling the click event of
the ``Show selected animals&rsquo;&rsquo;, which displays a list of the
selected elements. The <code>selection.selected()</code> call returns the selected
elements as a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>.
</p>

<div class="org-src-container">

<pre class="src src-js" id="ordered-list-show-animals">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">showAnimals</span>() {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">s</span> = <span style="color: #008000;">""</span>;
    selection.selected().forEach(<span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">v</span>) { 
      s = s + selectables[v].textContent + <span style="color: #008000;">" "</span>; 
    });
    document.getElementById(<span style="color: #008000;">"animal_list"</span>).textContent = s; 
  }
  document.getElementById(<span style="color: #008000;">"show_animals"</span>).addEventListener(<span style="color: #008000;">"click"</span>, showAnimals);
</pre>
</div>

<p>
Another means to inspect the current selection state, not used here,
is the <code>isSelected(i)</code> method that returns the selection state of
element <code>i</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Example: selection geometry that is both row-wise ordered and rectangular</h2>
<div class="outline-text-2" id="text-3">
<script type="text/javascript">
  function createCanvas (parent) {
  
    var canvas = document.createElement("canvas");
    canvas.style.position = 'absolute';
    parent.insertBefore(canvas, parent.firstChild);
  
    $(window).resize(resizeCanvas); 
    resizeCanvas();
  
    return canvas;
  
    function resizeCanvas() {
      var rect = parent.getBoundingClientRect();
      canvas.width = rect.right - rect.left;
      canvas.height = rect.bottom - rect.top;    
    }
  }
  
    function topLeftCorner(r) { return { x: r.left, y: r.top }; }
      
    function offsetRectangle(p, r) {
      return {
        left: r.left - p.x, top: r.top - p.y, 
        right: r.right - p.x, bottom: r.bottom - p.y 
      };
    }
  
    function getOffsetRectangle(parent, elem) {
      return offsetRectangle(topLeftCorner(parent.getBoundingClientRect()),
                             elem.getBoundingClientRect());
    }
  
    function offsetMousePos(parent, evt) { 
      var p = topLeftCorner(parent.getClientRects()[0]);
      return { x: evt.clientX - p.x, y: evt.clientY - p.y }; 
    }
  
  function mkRefresh (elements, cls) {
    return (function (changed) {
      changed.forEach(function (value, i) { 
        $(elements[i]).toggleClass(cls, value); 
      });
    });
  }
  
  // row-wise geometry
  var RowwiseGeometry = function (parent, elements) {
    this._parent = parent;
    this._elements = elements;
  }
  RowwiseGeometry.prototype = Object.create(multiselect.DefaultGeometry.prototype);
  
    RowwiseGeometry.prototype.m2v = function(mp) {
      for (var i=0; i<this._elements.length; ++i) {
        var r = getOffsetRectangle(this._parent, this._elements[i]);
        if (pointInRectangle(mp, r)) return { index: i, point: mp };        
      }
      return { index: null, point: mp };
    }
  
    RowwiseGeometry.prototype.extendPath = function(path, p) {
      if (path.length > 0 &&
          multiselect.anchor(path).index !== null && p.index === null) return null;
      if (path.length == 2) path.pop();
      path.push(p); 
    }
  
    RowwiseGeometry.prototype.selectionDomain = function(path) {
      var J = multiselect.makeEmptyMap();
      var a = multiselect.anchor(path);
      var b = multiselect.activeEnd(path);
  
      if (a.index !== null) {
        for (var i=Math.min(a.index, b.index); i<=Math.max(a.index, b.index); ++i) 
          J.set(i, true);
      } else {
        var r1 = { left:   Math.min(a.point.x, b.point.x),
                   right:  Math.max(a.point.x, b.point.x),
                   top:    Math.min(a.point.y, b.point.y),
                   bottom: Math.max(a.point.y, b.point.y) };
        for (var i = 0; i < this._elements.length; ++i) {
          var r2 = getOffsetRectangle(this._parent, this._elements[i]);
          if (rectangleIntersect(r1, r2)) J.set(i, true);
        }
      }
  
      return J;
    }
  
    function rectangleIntersect(r1, r2) {
      return r1.left <= r2.right && r1.right >= r2.left && 
             r1.top <= r2.bottom && r1.bottom >= r2.top;
    }
  
    RowwiseGeometry.prototype.step = function (dir, p) {
      if (p.index === null) return p;
      var ind = null;
      switch (dir) {
      case multiselect.LEFT:  ind = Math.max(p.index - 1, 0); break;
      case multiselect.RIGHT: ind = Math.min(p.index + 1, this._elements.length-1); break;
      case multiselect.UP: 
        ind = findClosestP.call(this, this._parent, this._elements, p.index, isAbove); 
        break;
      case multiselect.DOWN: 
        ind = findClosestP.call(this, this._parent, this._elements, p.index, 
                                      function (a, b) { return isAbove(b, a); }); 
        break; 
      default: return p;
      }
      return { index: ind, point: centerPoint(getOffsetRectangle(this._parent, this._elements[ind])) };
    }
  
    function centerPoint (r) { return { x: (r.left + r.right)/2, 
                                        y: (r.top + r.bottom)/2 }; }
  
    function distance (p1, p2) {
      var dx = p1.x - p2.x;
      var dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  
    function isAbove(r1, r2) { return centerPoint(r2).y < r1.top; }
  
    function findClosestP(parent, elements, j, pred) {
      var r = getOffsetRectangle(parent, elements[j]);
      var candidateIndex = null; 
      var candidateDistance = Number.MAX_VALUE;
  
      for (var i=0; i<elements.length; ++i) {
        var rc = getOffsetRectangle(parent, elements[i]);
        if (pred(r, rc) && distance(centerPoint(r), centerPoint(rc)) < candidateDistance) {
          candidateIndex = i; 
          candidateDistance = distance(centerPoint(r), centerPoint(rc));
        }
      }
      if (candidateIndex === null) return j; else return candidateIndex;
    }
  
    RowwiseGeometry.prototype.filter = function(p) {   
      var J = multiselect.makeEmptyMap();
      for (var i = 0; i < this._elements.length; ++i) if (p(i)) J.set(i, true);
      return J;
    }
  
    RowwiseGeometry.prototype.defaultCursor = function (dir) {
      var ind;
      switch (dir) {
      case multiselect.RIGHT: 
      case multiselect.DOWN: ind = 0; break;
      case multiselect.LEFT: 
      case multiselect.UP: ind = this._elements.length - 1; break;
      default: return undefined;
      }
      return { index: ind, point: centerPoint(getOffsetRectangle(this._parent, this._elements[ind])) };
    }
  
  // Mouse events
  function setupMouseEvents (parent, canvas, selection) {
  
    function mousedownHandler(evt) {
  
      var mousePos = selection.geometry().m2v(offsetMousePos(parent, evt));
      switch (modifierKeys(evt)) {
      case M_NONE: selection.click(mousePos); break;
      case M_CMD: selection.cmdClick(mousePos); break;
      case M_SHIFT: selection.shiftClick(mousePos); break;
      default: return;
      }    
  
      selection.geometry().drawIndicators(selection, canvas, true, true, false);
      document.addEventListener('mousemove', mousemoveHandler, false);
      document.addEventListener('mouseup', mouseupHandler, false);
      evt.preventDefault();
      evt.stopPropagation();
    };
  
    function mousemoveHandler (evt) {
      evt.preventDefault();
      evt.stopPropagation();
      var mousePos = selection.geometry().m2v(offsetMousePos(parent, evt));
      selection.shiftClick(mousePos);
      selection.geometry().drawIndicators(selection, canvas, true, true, true);
    };
  
    function mouseupHandler (evt) {
      document.removeEventListener('mousemove', mousemoveHandler, false);
      document.removeEventListener('mouseup', mouseupHandler, false);
      selection.geometry().drawIndicators(selection, canvas, true, true, false);
    };
  
    parent.addEventListener('mousedown', mousedownHandler, false);
  }
  
  // Keyboard events
    function setupKeyboardEvents(parent, canvas, selection) {
  
      parent.addEventListener('keydown', keydownHandler, false);
      parent.addEventListener('mousedown', function() { parent.focus(); }, false);
  
      function keydownHandler(evt) {
        var handled = false; 
        var mk = modifierKeys(evt);
        switch (evt.which) {          
        case 37: handled = callArrow(mk, multiselect.LEFT); break;
        case 38: handled = callArrow(mk, multiselect.UP); break;             
        case 39: handled = callArrow(mk, multiselect.RIGHT); break;
        case 40: handled = callArrow(mk, multiselect.DOWN); break;
        case 32: handled = callSpace(mk); break;
        case 90: handled = callUndoRedo(mk); break;
        default: return; // exit this handler for unrecognized keys
        }
        if (!handled) return;
  
        // event is recognized
        selection.geometry().drawIndicators(selection, canvas, true, true, false);
        evt.preventDefault(); 
        evt.stopPropagation();
      }  
    
      function callUndoRedo (mk) {
        switch (mk) {
        case M_OPT: selection.undo(); break;
        case M_SHIFT_OPT: selection.redo(); break;
        default: return false;
        }      
        return true;
      }
  
      function callArrow (mk, dir) {
        switch (mk) {
        case M_NONE: selection.arrow(dir); break;
        case M_CMD: selection.cmdArrow(dir); break;
        case M_SHIFT: selection.shiftArrow(dir); break;
        default: return false;
        }
        return true;
      }
    
      function callSpace (mk) {
        switch (mk) {
        case M_NONE: selection.space(); break;
        case M_CMD: selection.cmdSpace(); break;
        case M_SHIFT: selection.shiftSpace(); break;
        default: return false;      
        }
        return true;
      }
    }

  document.addEventListener("DOMContentLoaded", function() { 
      var selectableArea2 = document.getElementById("selectable_area2");
      for (var i = 0; i<400; ++i) {
        var e = document.createElement("span");
        e.setAttribute("class", "selectable2");
        e.textContent = i;
        selectableArea2.appendChild(e);
      }
    
      var selectables2 = selectableArea2.getElementsByClassName("selectable2");
    
    var refresh2 = mkRefresh(selectables2, 'selected2');
    
      var geometry2 = new RowwiseGeometry(selectableArea2, selectables2);
      var selection2 = new multiselect.SelectionState(geometry2, refresh2, true);
    
      var canvas2 = createCanvas(selectableArea2);
      setupMouseEvents(selectableArea2, canvas2, selection2);
    setupKeyboardEvents(selectableArea2, canvas2, selection2);
    
      geometry2.drawIndicators = function (selection, canvas, drawAnchor, drawCursor, drawRubber) {
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (drawAnchor) { 
          ctx.strokeStyle = 'DarkRed';
          var p = multiselect.anchor(selection.selectionPath());
          if (p !== undefined) {
            if (p.index === null) { // in-between point, draw a circle
              ctx.beginPath();
              ctx.arc(p.point.x, p.point.y, 4, 0, Math.PI*2, true); 
              ctx.stroke();
            } else { // point on an element, draw a frame
              var r = getOffsetRectangle(canvas, selection.geometry()._elements[p.index]);
              ctx.strokeRect(r.left, r.top, r.right-r.left, r.bottom-r.top);
            }
          }
        }
        if (drawCursor) { 
          ctx.strokeStyle = 'blue';
          var p = selection.cursor();
          if (p !== undefined && p.index !== null) { 
            var r = getOffsetRectangle(canvas, selection.geometry()._elements[p.index]);
            ctx.strokeRect(r.left, r.top, r.right-r.left, r.bottom-r.top);
          }
        }
        if (drawRubber) { 
          ctx.strokeStyle = 'green';
          var p1 = multiselect.anchor(selection.selectionPath());
          if (p1 !== undefined && p1.index === null) {
            var p2 = multiselect.activeEnd(selection.selectionPath());
            ctx.strokeRect(Math.min(p1.point.x, p2.point.x),
                           Math.min(p1.point.y, p2.point.y),
                           Math.abs(p1.point.x-p2.point.x),
                           Math.abs(p1.point.y-p2.point.y));
          }
        }
      }
  });
</script>

<p>
This section introduces another selection context, with quite a bit
more complex selection geometry.  The elements are ordered row-wise,
and the user can select a range of elements in this order with an
anchor and active end.  Alternatively, the anchor and active end can
be interpreted as corners of a rectangle, giving the user the means to
select all elements within a rectangular area.  This kind of a
dual selection mechanism is offered, for example, in Apple&rsquo;s iPhoto
application.  
</p>

<p>
This section also shows how to build support for rubber band selection
and selecting with keyboard, undo and redo operations, and how to
visualize the anchor, the active end, and the rubber band.  Again, the
<a href="example-2.html">example</a> can be opened in a separate window, and the <a href="example-2-source.html">complete source
code</a> viewed in one piece.
</p>

  <style>
    #selectable_area2 { border:1px solid black; cursor:default; }
    .selectable2 { outline:1px solid; padding:1px 4px 1px 4px; 
                   margin:2px; display:inline-block; }
    .selected2 { background-color: khaki; }
  </style>
<div id="selectable_area2" tabIndex="0"></div>

<p>
To become familiar with the supported selection features, try
clicking, command-clicking, and shift clicking the elements, as well
as dragging the mouse to perform rubber band selection. Try starting a
rubber band selection both on an element and between elements and
notice how in the former case elements within a range and in the
latter within a rectangular area are selected. Try starting a rubber
band <i>deselection</i> with a command-click on a selected element.  Try
releasing the mouse in a rubber band selection, and then picking it up
again with shift-click. Experiment with keyboard selection, using the
space and arrow keys with and withouth shift and command
modifiers. Finally, use the undo and redo operations, bound to
option-Z and shift-option-Z keys, respectively.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Selectable elements</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The selectable area is a <code>div</code>. The <code>tabIndex</code> attribute is defined so that
the element can acquire the keyboard focus.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-html">&lt;div id=<span style="color: #008000;">"selectable_area2"</span> tabIndex=<span style="color: #008000;">"0"</span>&gt;&lt;/div&gt;
</pre>
</div>

<p>
JavaScript code generates the selectable elements:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-selectables">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectableArea2</span> = document.getElementById(<span style="color: #008000;">"selectable_area2"</span>);
  <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span> = 0; i&lt;400; ++i) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">e</span> = document.createElement(<span style="color: #008000;">"span"</span>);
    e.setAttribute(<span style="color: #008000;">"class"</span>, <span style="color: #008000;">"selectable2"</span>);
    e.textContent = i;
    selectableArea2.appendChild(e);
  }

  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectables2</span> = selectableArea2.getElementsByClassName(<span style="color: #008000;">"selectable2"</span>);
</pre>
</div>

<p>
In this example, <code>selectable2</code> class indicates a selectable element, and <code>selected2</code> class
is added when the element is selected. The style definitions are as follows:
</p>

<div class="org-src-container">

<pre class="src src-html" id="row-wise-css">  &lt;<span style="color: #006699;">style</span>&gt;
    #selectable_area2 { border:1px solid black; cursor:default; }
    .selectable2 { outline:1px solid; padding:1px 4px 1px 4px; 
                   margin:2px; display:inline-block; }
    .selected2 { background-color: khaki; }
  &lt;/<span style="color: #006699;">style</span>&gt;
</pre>
</div>
</div>
</div>



<div id="outline-container-sec-refreshing-and-tracking" class="outline-3">
<h3 id="sec-refreshing-and-tracking"><a id="sec-3-2"></a><span class="section-number-3">3.2</span> Refreshing</h3>
<div class="outline-text-3" id="text-sec-refreshing-and-tracking">
<p>
As discussed above, every method of the <code>SelectionState</code> class that
may change the selection state invokes the refresh callback.  This
example uses <i>tracking of changes</i> so that the refresh callback
function only needs to iterate over the changed elements instead of
all selectable elements. We use a refresh function that toggles a class 
in further examples as well, and thus write a factory function
that can generate a refresh-callback for any set of DOM elements.
</p>

<div class="org-src-container">

<pre class="src src-js" id="mk-refresh"><span style="color: #0000FF;">function</span> <span style="color: #006699;">mkRefresh</span> (<span style="color: #BA36A5;">elements</span>, <span style="color: #BA36A5;">cls</span>) {
  <span style="color: #0000FF;">return</span> (<span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">changed</span>) {
    changed.forEach(<span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">value</span>, <span style="color: #BA36A5;">i</span>) { 
      $(elements[i]).toggleClass(cls, value); 
    });
  });
}
</pre>
</div>

<p>
The refresh function for this current example is:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-refresh"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">refresh2</span> = mkRefresh(selectables2, <span style="color: #008000;">'selected2'</span>);
</pre>
</div>


<p>
With tracking of changes on, the argument to the refresh callback is a
<code>Map</code> object. Its keys are the indices of the elements that were
changed, and its values either <code>true</code> or <code>false</code>, indicating the
current selection state.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Selection geometry</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The selection geometry again stores a reference to the collection of
the selectable elements. It also stores a reference to a DOM object
surrounding the selectable elements. This <code>parent</code> object is used
in definining mouse coordinates that are invariant to the location of
the parent object on the page.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">RowwiseGeometry</span> = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">elements</span>) {
  <span style="color: #8b1a1a;">this</span>._parent = parent;
  <span style="color: #8b1a1a;">this</span>._elements = elements;
}
RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span> = Object.create(multiselect.DefaultGeometry.<span style="color: #8b1a1a;">prototype</span>);
</pre>
</div>

<p>
Coordinates in the selection space can indicate either an element
index or a point ``in-between&rsquo;&rsquo;.  We choose to represent a coordinate
as an object that has two members, <code>index</code> an <code>point</code>. The in-between
coordinate values are recognized by <code>index</code> that has value <code>null</code>.  
The <code>point</code> member is a mouse coordinate.
The <code>m2v</code> method constructs a coordinate object:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry-m2v">  RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span>.m2v = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">mp</span>) {
    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=0; i&lt;<span style="color: #8b1a1a;">this</span>._elements.length; ++i) {
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r</span> = getOffsetRectangle(<span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements[i]);
      <span style="color: #0000FF;">if</span> (pointInRectangle(mp, r)) <span style="color: #0000FF;">return</span> { index: i, point: mp };        
    }
    <span style="color: #0000FF;">return</span> { index: <span style="color: #8b1a1a;">null</span>, point: mp };
  }
</pre>
</div>

<p>
The <code>getOffsetRectangle(a, b)</code> returns the bounding box of <code>b</code> in
coordinates relative to the top-left corner of the bounding box of <code>a</code>:
</p>

<div class="org-src-container">

<pre class="src src-js" id="get-offset-rectangle">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">topLeftCorner</span>(<span style="color: #BA36A5;">r</span>) { <span style="color: #0000FF;">return</span> { x: r.left, y: r.top }; }
    
  <span style="color: #0000FF;">function</span> <span style="color: #006699;">offsetRectangle</span>(<span style="color: #BA36A5;">p</span>, <span style="color: #BA36A5;">r</span>) {
    <span style="color: #0000FF;">return</span> {
      left: r.left - p.x, top: r.top - p.y, 
      right: r.right - p.x, bottom: r.bottom - p.y 
    };
  }

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">getOffsetRectangle</span>(<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">elem</span>) {
    <span style="color: #0000FF;">return</span> offsetRectangle(topLeftCorner(parent.getBoundingClientRect()),
                           elem.getBoundingClientRect());
  }
</pre>
</div>

<p>
As mentioned above, the user can select a range or a rectangular area
of elements. Which mechanism is used depends on from where a selection
command starts: if the anchor is on an element, row-wise selection is
used, if not, rectangular selection is used. The <code>selectionDomain</code>
function thus first inspects the anchor&rsquo;s <code>index</code> to determine the
kind of coordinate the anchor is, and then either interprets the
anchor and the active end as the endpoints of a range or as the
corners of a rectangle:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry-selection-domain">  RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span>.selectionDomain = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">path</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">J</span> = multiselect.makeEmptyMap();
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">a</span> = multiselect.anchor(path);
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">b</span> = multiselect.activeEnd(path);

    <span style="color: #0000FF;">if</span> (a.index !== <span style="color: #8b1a1a;">null</span>) {
      <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=Math.min(a.index, b.index); i&lt;=Math.max(a.index, b.index); ++i) 
        J.set(i, <span style="color: #8b1a1a;">true</span>);
    } <span style="color: #0000FF;">else</span> {
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r1</span> = { left:   Math.min(a.point.x, b.point.x),
                 right:  Math.max(a.point.x, b.point.x),
                 top:    Math.min(a.point.y, b.point.y),
                 bottom: Math.max(a.point.y, b.point.y) };
      <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span> = 0; i &lt; <span style="color: #8b1a1a;">this</span>._elements.length; ++i) {
        <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r2</span> = getOffsetRectangle(<span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements[i]);
        <span style="color: #0000FF;">if</span> (rectangleIntersect(r1, r2)) J.set(i, <span style="color: #8b1a1a;">true</span>);
      }
    }

    <span style="color: #0000FF;">return</span> J;
  }
</pre>
</div>

<p>
The <code>rectangeIntersect</code> helper function is as follows:
</p>

<div class="org-src-container">

<pre class="src src-js" id="rectangle-intersect">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">rectangleIntersect</span>(<span style="color: #BA36A5;">r1</span>, <span style="color: #BA36A5;">r2</span>) {
    <span style="color: #0000FF;">return</span> r1.left &lt;= r2.right &amp;&amp; r1.right &gt;= r2.left &amp;&amp; 
           r1.top &lt;= r2.bottom &amp;&amp; r1.bottom &gt;= r2.top;
  }
</pre>
</div>

<p>
This selection geometry overrides the <code>extendPath(path, p)</code> method.  The
<code>click</code>, <code>cmdClick</code>, and <code>shiftClick</code> methods call <code>extendPath</code> to add
a selection space point to the current selection path. Prior to
pushing the new point to <code>path</code> array, this <code>extendPath</code>
implementation performs two tasks.  First, only the first and last
point of the selection path (anchor and active end) are of importance
in this geometry. Therefore, if the path already 
has two elements, the previous active end is discarded.<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup> 
Second, if the anchor is on an element, we insist
that the active end is also on an element: trying to extend the path
with an in-between point has no effect in this case.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry-extend-path">  RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span>.extendPath = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">path</span>, <span style="color: #BA36A5;">p</span>) {
    <span style="color: #0000FF;">if</span> (path.length &gt; 0 &amp;&amp;
        multiselect.anchor(path).index !== <span style="color: #8b1a1a;">null</span> &amp;&amp; p.index === <span style="color: #8b1a1a;">null</span>) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">null</span>;
    <span style="color: #0000FF;">if</span> (path.length == 2) path.pop();
    path.push(p); 
  }
</pre>
</div>

<p>
The library expects that <code>extendPath</code> returns <code>null</code> if
the selection path is not changed.
</p>
</div>
</div>

<div id="outline-container-sec-create-selection-state-2" class="outline-3">
<h3 id="sec-create-selection-state-2"><a id="sec-3-4"></a><span class="section-number-3">3.4</span> Selection state object</h3>
<div class="outline-text-3" id="text-sec-create-selection-state-2">
<p>
The <code>SelectionState</code> object is created as before, but this time 
tracking is set to <code>true</code>.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-create-selection-state">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">geometry2</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">RowwiseGeometry</span>(selectableArea2, selectables2);
  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selection2</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">multiselect.SelectionState</span>(geometry2, refresh2, <span style="color: #8b1a1a;">true</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Mouse events</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Setting up mouse events for the current example is a bit more involved
because rubber band selection requires handlers for <code>mousemove</code> and
<code>mouseup</code> events. Further, the event handlers make calls to a function
that visualizes the anchor and active end.
</p>

<p>
The interplay of handlers of different mouse events can be defined in
many ways, so the code below should be considered as one possible
arrangement. The handler for the <code>mousedown</code> event in the selectable
area (<code>parent</code>) is registered at all times.  As its first task, it
registers handlers for <code>mousemove</code> and <code>mouseup</code> events. These are set
for the entire document, as the mouse can wander outside of the
selectable area.  The handler for the <code>mouseup</code> event removes itself
and the <code>mousemove</code> handler. 
</p>


<div class="org-src-container">

<pre class="src src-js" id="setup-mouse-events"><span style="color: #0000FF;">function</span> <span style="color: #006699;">setupMouseEvents</span> (<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">canvas</span>, <span style="color: #BA36A5;">selection</span>) {

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">mousedownHandler</span>(<span style="color: #BA36A5;">evt</span>) {

    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">mousePos</span> = selection.geometry().m2v(offsetMousePos(parent, evt));
    <span style="color: #0000FF;">switch</span> (modifierKeys(evt)) {
    <span style="color: #0000FF;">case</span> M_NONE: selection.click(mousePos); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> M_CMD: selection.cmdClick(mousePos); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> M_SHIFT: selection.shiftClick(mousePos); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span>;
    }    

    selection.geometry().drawIndicators(selection, canvas, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">false</span>);
    document.addEventListener(<span style="color: #008000;">'mousemove'</span>, mousemoveHandler, <span style="color: #8b1a1a;">false</span>);
    document.addEventListener(<span style="color: #008000;">'mouseup'</span>, mouseupHandler, <span style="color: #8b1a1a;">false</span>);
    evt.preventDefault();
    evt.stopPropagation();
  };

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">mousemoveHandler</span> (<span style="color: #BA36A5;">evt</span>) {
    evt.preventDefault();
    evt.stopPropagation();
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">mousePos</span> = selection.geometry().m2v(offsetMousePos(parent, evt));
    selection.shiftClick(mousePos);
    selection.geometry().drawIndicators(selection, canvas, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">true</span>);
  };

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">mouseupHandler</span> (<span style="color: #BA36A5;">evt</span>) {
    document.removeEventListener(<span style="color: #008000;">'mousemove'</span>, mousemoveHandler, <span style="color: #8b1a1a;">false</span>);
    document.removeEventListener(<span style="color: #008000;">'mouseup'</span>, mouseupHandler, <span style="color: #8b1a1a;">false</span>);
    selection.geometry().drawIndicators(selection, canvas, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">false</span>);
  };

  parent.addEventListener(<span style="color: #008000;">'mousedown'</span>, mousedownHandler, <span style="color: #8b1a1a;">false</span>);
}
</pre>
</div>

<p>
There are three further noteworthy issues in the code above.  
</p>

<ol class="org-ol">
<li>A mouse move during rubber band selection is semantically
equivalent to a shift-click. The <code>mousemoveHandler</code> thus acquires a
selection space coordinate and passes it to the <code>shiftClick</code> method.</li>

<li>The calls to <code>drawIndicators</code> function are what display the anchor,
the active end, and the rubber band indicators. These markers are
drawn on a HTML5 <i>canvas</i> element that overlaps the selectable
area.  The three boolean arguments specify which of the three
indicators (in the order anchor, active end, rubber band) should be
shown; <code>true</code> means to show, <code>false</code> to hide.  In this example we
make <code>drawIndicators</code> a method of the geometry object.  This
because we reuse the <code>setupMouseEvents</code> function in a later example
that uses a different selection geometry. A different geometry
means a different visualization, so it is convenient to couple the
visualization to the geometry.</li>

<li>Even though the mouse events are inevitably a bit more complex, the
MultiselectJS selection services are obtained by the same simple calls
to the three different click methods.</li>
</ol>

<p>
We remark that a common feature in multi-selection contexts is
drag-and-drop of selected elements. The above event handlers do not
recognize the start of a drag-and-drop event.
</p>

<p>
A few tasks remain. First, the mouse setup code uses a helper function
<code>offsetMousePos</code> to translates an event&rsquo;s mouse coordinates to 
coordinates relative to another DOM element (<code>parent</code>). Its implementation
is as follows:
</p>

<div class="org-src-container">

<pre class="src src-js" id="offset-mouse-pos">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">offsetMousePos</span>(<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">evt</span>) { 
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = topLeftCorner(parent.getClientRects()[0]);
    <span style="color: #0000FF;">return</span> { x: evt.clientX - p.x, y: evt.clientY - p.y }; 
  }
</pre>
</div>

<p>
Second, the event handlers must be activated:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-setup-mouse-events">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">canvas2</span> = createCanvas(selectableArea2);
  setupMouseEvents(selectableArea2, canvas2, selection2);
</pre>
</div>

<p>
Section <a href="#sec-path-visualization">3.7</a> shows the implementations of the
<code>createCanvas</code> and <code>drawIndicators</code> functions.
</p>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Keyboard events</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Various keyboard commands can accomplish the same selection tasks as
clicks&#x2014;the selection space point associated with a keyboard command
is the value of the <i>keyboard cursor</i>.  The keyboard cursor is often
the same as the active end; a click, command-click, and shift-click
set the cursor to and the active end to the clicked point.  The cursor
can, however, deviate from the active end.  For example, the arrow
keys, unmodified, move the keyboard cursor but do not change the
selection path. Further, the keyboard cursor can be defined even if
the selection path is empty, e.g., after an <code>undo</code> command.
</p>

<p>
Selection geometry&rsquo;s <code>step(dir, point)</code> method determines how arrow
keys move the keyboard cursor. The <code>dir</code> parameter is one of constants
<code>UP</code>, <code>DOWN</code>, <code>LEFT</code>, <code>RIGHT</code>. In this example, <code>step</code> only moves the
cursor if it is on an element. When moving to a new element, the
<code>point</code> member of the cursor object is set to the center point of the
moved-to element.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry-step">  RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span>.step = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">dir</span>, <span style="color: #BA36A5;">p</span>) {
    <span style="color: #0000FF;">if</span> (p.index === <span style="color: #8b1a1a;">null</span>) <span style="color: #0000FF;">return</span> p;
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">ind</span> = <span style="color: #8b1a1a;">null</span>;
    <span style="color: #0000FF;">switch</span> (dir) {
    <span style="color: #0000FF;">case</span> multiselect.LEFT:  ind = Math.max(p.index - 1, 0); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.RIGHT: ind = Math.min(p.index + 1, <span style="color: #8b1a1a;">this</span>._elements.length-1); <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.UP: 
      ind = findClosestP.call(<span style="color: #8b1a1a;">this</span>, <span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements, p.index, isAbove); 
      <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.DOWN: 
      ind = findClosestP.call(<span style="color: #8b1a1a;">this</span>, <span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements, p.index, 
                                    <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">a</span>, <span style="color: #BA36A5;">b</span>) { <span style="color: #0000FF;">return</span> isAbove(b, a); }); 
      <span style="color: #0000FF;">break</span>; 
    <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span> p;
    }
    <span style="color: #0000FF;">return</span> { index: ind, point: centerPoint(getOffsetRectangle(<span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements[ind])) };
  }
</pre>
</div>

<p>
Moving left and right is simple: decrement or increment the cursor&rsquo;s
index.  Moving up or down is more complex. There are several sensible
choices for what <i>next element above</i> or <i>next element
below</i> mean, even for what <i>above</i> and <i>below</i> mean.
We consider one element above the other if the former&rsquo;s
center point is above the top edge of the latter. The next element
above of some element <code>i</code> is the closest, in distance between center
points, of all elements that are above <code>i</code>. Next below is defined
analogously. The <code>findClosestP(parent, elements, i, pred)</code> helper function 
performs these determinations, finding the closest element to <code>i</code> 
that satisfies <code>pred</code>:
</p>

<div class="org-src-container">

<pre class="src src-js" id="rectangle-helpers-3">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">centerPoint</span> (<span style="color: #BA36A5;">r</span>) { <span style="color: #0000FF;">return</span> { x: (r.left + r.right)/2, 
                                      y: (r.top + r.bottom)/2 }; }

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">distance</span> (<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">dx</span> = p1.x - p2.x;
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">dy</span> = p1.y - p2.y;
    <span style="color: #0000FF;">return</span> Math.sqrt(dx * dx + dy * dy);
  }

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">isAbove</span>(<span style="color: #BA36A5;">r1</span>, <span style="color: #BA36A5;">r2</span>) { <span style="color: #0000FF;">return</span> centerPoint(r2).y &lt; r1.top; }

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">findClosestP</span>(<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">elements</span>, <span style="color: #BA36A5;">j</span>, <span style="color: #BA36A5;">pred</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r</span> = getOffsetRectangle(parent, elements[j]);
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">candidateIndex</span> = <span style="color: #8b1a1a;">null</span>; 
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">candidateDistance</span> = Number.MAX_VALUE;

    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span>=0; i&lt;elements.length; ++i) {
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">rc</span> = getOffsetRectangle(parent, elements[i]);
      <span style="color: #0000FF;">if</span> (pred(r, rc) &amp;&amp; distance(centerPoint(r), centerPoint(rc)) &lt; candidateDistance) {
        candidateIndex = i; 
        candidateDistance = distance(centerPoint(r), centerPoint(rc));
      }
    }
    <span style="color: #0000FF;">if</span> (candidateIndex === <span style="color: #8b1a1a;">null</span>) <span style="color: #0000FF;">return</span> j; <span style="color: #0000FF;">else</span> <span style="color: #0000FF;">return</span> candidateIndex;
  }
</pre>
</div>

<p>
With the <code>step</code> function defined, setting up the keyboard events is
straightforward: the event handler for <code>keydown</code> recognizes the key
combination of a command, invokes the desired <code>SelectionState</code>&rsquo;s
method, and calls a function to draws the indicators.  We bind the
handler to <code>parent</code>, the DOM element that is the selectable area, to
avoid conflicts; the bindings are only in effect when <code>parent</code> has
focus. The <code>mousedown</code> handler is defined to give <code>parent</code> focus when
it is clicked.
</p>

<div class="org-src-container">

<pre class="src src-js" id="setup-keyboard-events">  <span style="color: #0000FF;">function</span> <span style="color: #006699;">setupKeyboardEvents</span>(<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">canvas</span>, <span style="color: #BA36A5;">selection</span>) {

    parent.addEventListener(<span style="color: #008000;">'keydown'</span>, keydownHandler, <span style="color: #8b1a1a;">false</span>);
    parent.addEventListener(<span style="color: #008000;">'mousedown'</span>, <span style="color: #0000FF;">function</span>() { parent.focus(); }, <span style="color: #8b1a1a;">false</span>);

    <span style="color: #0000FF;">function</span> <span style="color: #006699;">keydownHandler</span>(<span style="color: #BA36A5;">evt</span>) {
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">handled</span> = <span style="color: #8b1a1a;">false</span>; 
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">mk</span> = modifierKeys(evt);
      <span style="color: #0000FF;">switch</span> (evt.which) {          
      <span style="color: #0000FF;">case</span> 37: handled = callArrow(mk, multiselect.LEFT); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 38: handled = callArrow(mk, multiselect.UP); <span style="color: #0000FF;">break</span>;             
      <span style="color: #0000FF;">case</span> 39: handled = callArrow(mk, multiselect.RIGHT); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 40: handled = callArrow(mk, multiselect.DOWN); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 32: handled = callSpace(mk); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 90: handled = callUndoRedo(mk); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">exit this handler for unrecognized keys</span>
      }
      <span style="color: #0000FF;">if</span> (!handled) <span style="color: #0000FF;">return</span>;

      <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">event is recognized</span>
      selection.geometry().drawIndicators(selection, canvas, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">true</span>, <span style="color: #8b1a1a;">false</span>);
      evt.preventDefault(); 
      evt.stopPropagation();
    }  
  
    <span style="color: #0000FF;">function</span> <span style="color: #006699;">callUndoRedo</span> (<span style="color: #BA36A5;">mk</span>) {
      <span style="color: #0000FF;">switch</span> (mk) {
      <span style="color: #0000FF;">case</span> M_OPT: selection.undo(); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> M_SHIFT_OPT: selection.redo(); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">false</span>;
      }      
      <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
    }

    <span style="color: #0000FF;">function</span> <span style="color: #006699;">callArrow</span> (<span style="color: #BA36A5;">mk</span>, <span style="color: #BA36A5;">dir</span>) {
      <span style="color: #0000FF;">switch</span> (mk) {
      <span style="color: #0000FF;">case</span> M_NONE: selection.arrow(dir); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> M_CMD: selection.cmdArrow(dir); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> M_SHIFT: selection.shiftArrow(dir); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">false</span>;
      }
      <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
    }
  
    <span style="color: #0000FF;">function</span> <span style="color: #006699;">callSpace</span> (<span style="color: #BA36A5;">mk</span>) {
      <span style="color: #0000FF;">switch</span> (mk) {
      <span style="color: #0000FF;">case</span> M_NONE: selection.space(); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> M_CMD: selection.cmdSpace(); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> M_SHIFT: selection.shiftSpace(); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">false</span>;      
      }
      <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
    }
  }
</pre>
</div>

<p>
The main switch statement recognizes the arrow
keys, space, and the character <code>z</code> (for undo and redo), and delegates
to different helper functions. The helper functions inspect the
modifers and dispatch to the appropriate <code>SelectionState</code> method,
or return <code>false</code> if the key binding is not recognized.
</p>

<p>
A call to <code>setupKeyboardEvents</code> registers the keyboard event handler:
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-setup-keyboard-events">setupKeyboardEvents(selectableArea2, canvas2, selection2);
</pre>
</div>

<p>
To complete the keyboard selection functionality, we override the
<code>defaultCursor</code> method so that keyboard cursor has sensible defaults
when nothing has yet been selected: the right and down arrow keys
start from the first element, the left and up arrow keys from the last.
</p>

<div class="org-src-container">

<pre class="src src-js" id="row-wise-geometry-default-cursor">  RowwiseGeometry.<span style="color: #8b1a1a;">prototype</span>.defaultCursor = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">dir</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">ind</span>;
    <span style="color: #0000FF;">switch</span> (dir) {
    <span style="color: #0000FF;">case</span> multiselect.RIGHT: 
    <span style="color: #0000FF;">case</span> multiselect.DOWN: ind = 0; <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">case</span> multiselect.LEFT: 
    <span style="color: #0000FF;">case</span> multiselect.UP: ind = <span style="color: #8b1a1a;">this</span>._elements.length - 1; <span style="color: #0000FF;">break</span>;
    <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">undefined</span>;
    }
    <span style="color: #0000FF;">return</span> { index: ind, point: centerPoint(getOffsetRectangle(<span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements[ind])) };
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-path-visualization" class="outline-3">
<h3 id="sec-path-visualization"><a id="sec-3-7"></a><span class="section-number-3">3.7</span> Visualizing anchor, cursor, and rubberband</h3>
<div class="outline-text-3" id="text-sec-path-visualization">
<p>
Sometimes it is useful to show where the anchor and keyboard cursor
reside. Many expect to see a rectangular rubber band when selecting
via dragging. In &ldquo;lasso&rdquo; selection, it is particularly important to
have a visual indicator of the selected area.  Displaying these
indicators can be implemented without help from MultiselectJS but to ease
the task, <code>SelectionState</code> has methods <code>selectionPath</code> and <code>cursor</code>
for querying the current selection path and cursor, respectively.  The
former returns an array of points and the latter a single point. These
points are selection space coordinates and thus something akin to an
inverse of the <code>m2v</code> transformation is necessary prior to their use in
visualization. The desired visualization, however, is likely not a
single point, but insted perhaps a frame over the selected
element. Since the details of the &ldquo;inverse&rdquo; transformation varies from
one selection context to another, its definition is left completely to
the client.
</p>

<p>
In this example the visual indicators are drawn on a canvas placed on
top of the selectable area. To maintain the overlap, the canvas&rsquo; size
and position are recalculated whenever the <code>window</code> object is resized.
</p>

<div class="org-src-container">

<pre class="src src-js" id="create-canvas"><span style="color: #0000FF;">function</span> <span style="color: #006699;">createCanvas</span> (<span style="color: #BA36A5;">parent</span>) {

  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">canvas</span> = document.createElement(<span style="color: #008000;">"canvas"</span>);
  canvas.style.position = <span style="color: #008000;">'absolute'</span>;
  parent.insertBefore(canvas, parent.firstChild);

  $(window).resize(resizeCanvas); 
  resizeCanvas();

  <span style="color: #0000FF;">return</span> canvas;

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">resizeCanvas</span>() {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">rect</span> = parent.getBoundingClientRect();
    canvas.width = rect.right - rect.left;
    canvas.height = rect.bottom - rect.top;    
  }
}
</pre>
</div>

<p>
The <code>drawIndicators</code> function is defined as a method of the
<code>geometry2</code> object. The function first clears all indicators, then
draws some or all of anchor, cursor, and rubber band based on the
<code>drawAnchor</code>, <code>drawCursor</code>, and <code>drawRubber</code> flags.  The tests for
<code>undefined</code> points are to safeguard for the case where there is no
anchor (the selection path is empty) or no cursor.
</p>

<p>
Anchor is drawn as a circle for in-between points (points whose
<code>index</code> is <code>null</code>) and as a rectangle for points on an element.
Cursor is not drawn at all for in-between points. 
</p>

<div class="org-src-container">

<pre class="src src-js" id="draw-indicators">  geometry2.drawIndicators = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">selection</span>, <span style="color: #BA36A5;">canvas</span>, <span style="color: #BA36A5;">drawAnchor</span>, <span style="color: #BA36A5;">drawCursor</span>, <span style="color: #BA36A5;">drawRubber</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">ctx</span> = canvas.getContext(<span style="color: #008000;">'2d'</span>);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    <span style="color: #0000FF;">if</span> (drawAnchor) { 
      ctx.strokeStyle = <span style="color: #008000;">'DarkRed'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = multiselect.anchor(selection.selectionPath());
      <span style="color: #0000FF;">if</span> (p !== <span style="color: #8b1a1a;">undefined</span>) {
        <span style="color: #0000FF;">if</span> (p.index === <span style="color: #8b1a1a;">null</span>) { <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">in-between point, draw a circle</span>
          ctx.beginPath();
          ctx.arc(p.point.x, p.point.y, 4, 0, Math.PI*2, <span style="color: #8b1a1a;">true</span>); 
          ctx.stroke();
        } <span style="color: #0000FF;">else</span> { <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">point on an element, draw a frame</span>
          <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r</span> = getOffsetRectangle(canvas, selection.geometry()._elements[p.index]);
          ctx.strokeRect(r.left, r.top, r.right-r.left, r.bottom-r.top);
        }
      }
    }
    <span style="color: #0000FF;">if</span> (drawCursor) { 
      ctx.strokeStyle = <span style="color: #008000;">'blue'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = selection.cursor();
      <span style="color: #0000FF;">if</span> (p !== <span style="color: #8b1a1a;">undefined</span> &amp;&amp; p.index !== <span style="color: #8b1a1a;">null</span>) { 
        <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r</span> = getOffsetRectangle(canvas, selection.geometry()._elements[p.index]);
        ctx.strokeRect(r.left, r.top, r.right-r.left, r.bottom-r.top);
      }
    }
    <span style="color: #0000FF;">if</span> (drawRubber) { 
      ctx.strokeStyle = <span style="color: #008000;">'green'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p1</span> = multiselect.anchor(selection.selectionPath());
      <span style="color: #0000FF;">if</span> (p1 !== <span style="color: #8b1a1a;">undefined</span> &amp;&amp; p1.index === <span style="color: #8b1a1a;">null</span>) {
        <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p2</span> = multiselect.activeEnd(selection.selectionPath());
        ctx.strokeRect(Math.min(p1.point.x, p2.point.x),
                       Math.min(p1.point.y, p2.point.y),
                       Math.abs(p1.point.x-p2.point.x),
                       Math.abs(p1.point.y-p2.point.y));
      }
    }
  }
</pre>
</div>

<p>
The second example is complete.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Example: snake selection geometry</h2>
<div class="outline-text-2" id="text-4">
<p>
<a href="example-3.html">this link</a>. 
</p>

<p>
The third example demonstrates a selection geometry where all points
of the selection path are relevant: the selection domain consists of
all the elements that the selection path touches.  
Instead of numbers, the selectable elements in this example are fish. 
Please experiment with the following selection context to understand
how this ``snake&rsquo;&rsquo; selection works.<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-html">&lt;div id=<span style="color: #008000;">"selectable_area3"</span> tabIndex=<span style="color: #008000;">"0"</span>&gt;&lt;/div&gt;
&lt;br&gt;
Filter: &lt;input type=<span style="color: #008000;">"text"</span> id=<span style="color: #008000;">"filter3"</span>&gt;&lt;/input&gt;
&lt;button id=<span style="color: #008000;">"commit_filter3"</span>&gt;Commit&lt;/button&gt;
</pre>
</div>

<p>
The selectable elements are again generated by JavaScript under a <code>div</code> on the page.
The code that populates the <code>fish</code> array is in <a href="fish.js">fish.js</a>.
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-selectables">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectableArea3</span> = $(<span style="color: #008000;">"#selectable_area3"</span>)[0];
  <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span> = 0; i&lt;fish.length; ++i) {
    $(selectableArea3).append(<span style="color: #008000;">"&lt;span class='selectable2'&gt;"</span> + fish[i] + <span style="color: #008000;">"&lt;/span&gt; "</span>);
  }
  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selectables3</span> = $(<span style="color: #008000;">".selectable2"</span>, selectableArea3);    
  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">filter3</span> = $(<span style="color: #008000;">"#filter3"</span>)[0];
  $(filter3).keyup(<span style="color: #0000FF;">function</span> () {    
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">str</span> = $(filter3).val(); 
    selection3.filter(<span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">i</span>){ <span style="color: #0000FF;">return</span> str !== <span style="color: #008000;">""</span> &amp;&amp; fish[i].indexOf(str)&gt;-1; });
  });
  $(<span style="color: #008000;">"#commit_filter3"</span>).click(<span style="color: #0000FF;">function</span>(){ selection3.commit(); });  

  selectableArea3.addEventListener(<span style="color: #008000;">'keydown'</span>, keydownHandler3, <span style="color: #8b1a1a;">false</span>);

  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">geometry2</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">RowwiseGeometry</span>(selectableArea3, selectables3);

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">keydownHandler3</span>(<span style="color: #BA36A5;">evt</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">draw</span> = <span style="color: #8b1a1a;">true</span>;
    <span style="color: #0000FF;">switch</span> (evt.which) {
      <span style="color: #0000FF;">case</span> 66: <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">s</span> = selection3.selectionPath(); s.pop(); selection3.setPath(s); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 70: <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">s</span> = selection3.selectionPath(); s.shift(); selection3.setPath(s); <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 82: selection3.setGeometry(geometry2); draw = <span style="color: #8b1a1a;">false</span>; <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> 83: selection3.setGeometry(geometry3); draw = <span style="color: #8b1a1a;">false</span>; <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">default</span>: <span style="color: #0000FF;">return</span>;
    }
    selection3.geometry().drawIndicators(selection3, canvas3, draw, draw, draw);
  }
</pre>
</div>

<p>
The styles <code>selectable2</code> and <code>selected2</code> are reused,
so we only style the selectable area:
</p>

<div class="org-src-container">

<pre class="src src-html" id="snake-css">&lt;<span style="color: #006699;">style</span>&gt; 
  #selectable_area3 { border:1px solid black; cursor:default; } 
&lt;/<span style="color: #006699;">style</span>&gt;
</pre>
</div>

<div id="selectable_area3" tabIndex="0"></div>
<br>
Filter: <input type="text" id="filter3"></input>
<button id="commit_filter3">Commit</button> 
<style> 
  #selectable_area3 { border:1px solid black; cursor:default; } 
</style>
<script>
  var fish = 
  [ "anchovy"
  , "angelfish"
  , "angelshark"
  , "barb"
  , "barracuda"
  , "basking shark"
  , "bass"
  , "blenny"
  , "blowfish"
  , "bluefin tuna"
  , "blue shark"
  , "bonito"
  , "bony fish"
  , "bull shark"
  , "carp"
  , "catfish"
  , "chub"
  , "clownfish"
  , "cod"
  , "coelacanth"
  , "cookiecutter shark"
  , "crappie"
  , "darter"
  , "devil ray"
  , "dogfish"
  , "dory"
  , "dragonfish"
  , "Dunkleosteus"
  , "eel"
  , "electric eel"
  , "elver"
  , "Emperor angelfish"
  , "fish"
  , "flounder"
  , "flying fish"
  , "Galapagos shark"
  , "gar"
  , "glassfish"
  , "goby"
  , "goldfish"
  , "grayling"
  , "great white shark"
  , "Greenland shark"
  , "grouper"
  , "grunion"
  , "gulper eel"
  , "guppy"
  , "haddock"
  , "hagfish"
  , "hake"
  , "halibut"
  , "hammerhead shark"
  , "hatchetfish"
  , "herring"
  , "humuhumu-nukunuku-apua'a"
  , "icefish"
  , "jackfish"
  , "john dory"
  , "koi"
  , "lake trout"
  , "lamprey"
  , "lanternfish"
  , "lemon shark"
  , "ling cod"
  , "loach"
  , "luminous shark"
  , "lungfish"
  , "mackerel"
  , "mako shark"
  , "manta ray"
  , "marlin"
  , "Megalodon"
  , "megamouth shark"
  , "minnow"
  , "monkfish"
  , "moray eel"
  , "mullet"
  , "needlefish"
  , "nurse shark"
  , "oarfish"
  , "orange roughy"
  , "Orthacanthus"
  , "paddlefish"
  , "parrotfish"
  , "perch"
  , "pike"
  , "pilot fish"
  , "piranha"
  , "pollock"
  , "pompano"
  , "porgy"
  , "Port Jackson shark"
  , "pufferfish"
  , "pupfish"
  , "queen triggerfish"
  , "quillfish"
  , "ray"
  , "remora"
  , "rockfish"
  , "roughy"
  , "sailfish"
  , "salmon"
  , "sardine"
  , "sawfish"
  , "sculpin"
  , "seabass"
  , "seadragon"
  , "seahorse"
  , "shad"
  , "shark"
  , "skate"
  , "smelt"
  , "snapper"
  , "sole"
  , "stingray"
  , "sturgeon"
  , "sunfish"
  , "swordfish"
  , "tarpon"
  , "tetra"
  , "three-spine stickleback"
  , "thresher shark"
  , "tiger shark"
  , "triggerfish"
  , "trout"
  , "tuna"
  , "tunny"
  , "turbot"
  , "upside-down catfish"
  , "velvetfish"
  , "viperfish"
  , "walleye"
  , "whale shark"
  , "whiting"
  , "wrasse"
  , "x-ray tetra"
  , "yellowjack"
  , "yellowtail"
  , "zebra bullhead shark"
  , "zebrafish" ]
  var SnakeGeometry = function (parent, elements) {
    this._parent = parent;
    this._elements = elements;
    this._k = 0;
  }
  SnakeGeometry.prototype = Object.create(multiselect.DefaultGeometry.prototype);
  
  SnakeGeometry.prototype.extendPath = function(path, p) { path.push(p); }
    SnakeGeometry.prototype.selectionDomain = function(path, source, J) {  
      if (J === undefined) J = multiselect.makeEmptyMap(); 
      switch (source) {
        case multiselect.C_SHIFT_CLICK: break;
        case multiselect.C_SET_PATH: 
        case undefined: 
          this._k = 0;
      }
      var prev = this._k;
      for (var i = this._k; i < path.length; ++i) {
        for (var j = 0; j < this._elements.length; ++j) {
          if (lineRectIntersect(path[i], path[prev],
                                getOffsetRectangle(this._parent, this._elements[j]))) J.set(j, true);
        }
        prev = i;
      }
      this._k = path.length - 1;
  
      return J;
    }
    SnakeGeometry.prototype.filter = function(p) {   
      var J = multiselect.makeEmptyMap();
      for (var i = 0; i < this._elements.length; ++i) if (p(i)) J.set(i, true);
      return J;
    }
  function lineRectIntersect(p1, p2, r) {
    if (!rectangleIntersect(mkRectangle(p1, p2), r)) return false; // if bounding boxes do not overlap, cannot intersect
    if (pointEquals(p1, p2)) return pointInRectangle(p1, r);
    var p = {};
    if (lineIntersect(p1, p2, { x: r.left, y: r.top }, { x: r.left, y: r.bottom }, p) === 1) return true;
    if (lineIntersect(p1, p2, { x: r.left, y: r.top }, { x: r.right, y: r.top }, p) === 1) return true;
    if (lineIntersect(p1, p2, { x: r.right, y: r.bottom }, { x: r.right, y: r.top }, p) === 1) return true;
    if (lineIntersect(p1, p2, { x: r.right, y: r.bottom }, { x: r.left, y: r.bottom }, p) === 1) return true;
    return pointInRectangle(p1, r) || pointInRectangle(p2, r);
  }
  
  function mkRectangle(p1, p2) {
    return { 
      left: Math.min(p1.x, p2.x),
      top: Math.min(p1.y, p2.y),
      right: Math.max(p1.x, p2.x),
      bottom: Math.max(p1.y, p2.y)
    };        
  }
  
  function pointEquals(p1, p2) { return p1.x === p2.x && p1.y === p2.y; }
    /* PORTED FROM:
  
     * lines_intersect:  AUTHOR: Mukesh Prasad
     *
     *   This function computes whether two line segments,
     *   respectively joining the input points (x1,y1) -- (x2,y2)
     *   and the input points (x3,y3) -- (x4,y4) intersect.
     *   If the lines intersect, the output variables x, y are
     *   set to coordinates of the point of intersection.
     *
     *   All values are in integers.  The returned value is rounded
     *   to the nearest integer point.
     *
     *   If non-integral grid points are relevant, the function
     *   can easily be transformed by substituting floating point
     *   calculations instead of integer calculations.
     *
     *   Entry
     *        x1, y1,  x2, y2   Coordinates of endpoints of one segment.
     *        x3, y3,  x4, y4   Coordinates of endpoints of other segment.
     *
     *   Exit
     *        x, y              Coordinates of intersection point.
     *
     *   The value returned by the function is one of:
     *
     *        DONT_INTERSECT    0
     *        DO_INTERSECT      1
     *        COLLINEAR         2
     *
     * Error conditions:
     *
     *     Depending upon the possible ranges, and particularly on 16-bit
     *     computers, care should be taken to protect from overflow.
     *
     *     In the following code, 'long' values have been used for this
     *     purpose, instead of 'int'.
     *
     */
  
    function sameSigns(a, b) { return a >= 0 && b >= 0 || a < 0 && b < 0; }
  
    function lineIntersect( p1,   /* First line segment */
                            p2,
                            p3,   /* Second line segment */
                            p4,
                            p5    /* Output value:
                                   * point of intersection */
                          )
    {
      const DONT_INTERSECT = 0;
      const DO_INTERSECT = 1;
      const COLLINEAR = 2;
  
      var a1, a2, b1, b2, c1, c2; /* Coefficients of line eqns. */
      var r1, r2, r3, r4;         /* 'Sign' values */
      var denom, offset, num;     /* Intermediate values */
  
      /* Compute a1, b1, c1, where line joining points 1 and 2
       * is "a1 x  +  b1 y  +  c1  =  0".
       */
  
      a1 = p2.y - p1.y;
      b1 = p1.x - p2.x;
      c1 = p2.x * p1.y - p1.x * p2.y;
  
      /* Compute r3 and r4.
       */
      r3 = a1 * p3.x + b1 * p3.y + c1;
      r4 = a1 * p4.x + b1 * p4.y + c1;
  
      /* Check signs of r3 and r4.  If both point 3 and point 4 lie on
       * same side of line 1, the line segments do not intersect.
       */
      if ( r3 != 0 &&
           r4 != 0 &&
           sameSigns( r3, r4 ))
        return ( DONT_INTERSECT );
  
      /* Compute a2, b2, c2 */
      a2 = p4.y - p3.y;
      b2 = p3.x - p4.x;
      c2 = p4.x * p3.y - p3.x * p4.y;
  
      /* Compute r1 and r2 */
      r1 = a2 * p1.x + b2 * p1.y + c2;
      r2 = a2 * p2.x + b2 * p2.y + c2;
  
      /* Check signs of r1 and r2.  If both point 1 and point 2 lie
       * on same side of second line segment, the line segments do
       * not intersect.
       */
      if ( r1 !== 0 &&
           r2 !== 0 &&
           sameSigns( r1, r2 ))
        return ( DONT_INTERSECT );
  
      /* Line segments intersect: compute intersection point. 
       */
  
      denom = a1 * b2 - a2 * b1;
      if ( denom === 0 )
        return ( COLLINEAR );
      // offset = denom < 0 ? - denom / 2 : denom / 2;
  
      // /* The denom/2 is to get rounding instead of truncating.  It
      //  * is added or subtracted to the numerator, depending upon the
      //  * sign of the numerator.
      //  */
  
      // num = b1 * c2 - b2 * c1;
      // p5.x = ( num < 0 ? num - offset : num + offset ) / denom;
  
      // num = a2 * c1 - a1 * c2;
      // p5.y = ( num < 0 ? num - offset : num + offset ) / denom;
  
      return DO_INTERSECT;
    } 
</script>
<script type="text/javascript">
  $(document).ready(function () {
      var selectableArea3 = $("#selectable_area3")[0];
      for (var i = 0; i<fish.length; ++i) {
        $(selectableArea3).append("<span class='selectable2'>" + fish[i] + "</span> ");
      }
      var selectables3 = $(".selectable2", selectableArea3);    
      var filter3 = $("#filter3")[0];
      $(filter3).keyup(function () {    
        var str = $(filter3).val(); 
        selection3.filter(function(i){ return str !== "" && fish[i].indexOf(str)>-1; });
      });
      $("#commit_filter3").click(function(){ selection3.commit(); });  
    
      selectableArea3.addEventListener('keydown', keydownHandler3, false);
    
      var geometry2 = new RowwiseGeometry(selectableArea3, selectables3);
    
      function keydownHandler3(evt) {
        var draw = true;
        switch (evt.which) {
          case 66: var s = selection3.selectionPath(); s.pop(); selection3.setPath(s); break;
          case 70: var s = selection3.selectionPath(); s.shift(); selection3.setPath(s); break;
          case 82: selection3.setGeometry(geometry2); draw = false; break;
          case 83: selection3.setGeometry(geometry3); draw = false; break;
          default: return;
        }
        selection3.geometry().drawIndicators(selection3, canvas3, draw, draw, draw);
      }
    var geometry3 = new SnakeGeometry(selectableArea3, selectables3);
    var selection3 = new multiselect.SelectionState(geometry3, mkRefresh(selectables3, 'selected2'), true);
      geometry3.drawIndicators = function (selection, canvas, drawAnchor, drawCursor, drawRubber) {
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (drawAnchor) { 
          ctx.strokeStyle = 'DarkRed';
          var p = multiselect.anchor(selection.selectionPath());
          if (p !== undefined) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI*2, true); 
            ctx.stroke();
          }
        }
        if (drawCursor) { 
          ctx.strokeStyle = 'blue';
          var p = selection.cursor();
          if (p !== undefined) { 
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI*2, true); 
            ctx.stroke();
          }
        }
        if (drawRubber) { 
          ctx.strokeStyle = 'green';
          var path = selection.selectionPath();
          if (path.length > 0) {
            ctx.moveTo(path[0].x, path[0].y);
            for (var i = 1; i < path.length; ++i) ctx.lineTo(path[i].x, path[i].y);
            ctx.stroke();
          }
        }
      }
      geometry2.drawIndicators = function (selection, canvas, drawAnchor, drawCursor, drawRubber) {
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (drawAnchor) { 
          ctx.strokeStyle = 'DarkRed';
          var p = multiselect.anchor(selection.selectionPath());
          if (p !== undefined) {
            if (p.index === null) { // in-between point, draw a circle
              ctx.beginPath();
              ctx.arc(p.point.x, p.point.y, 4, 0, Math.PI*2, true); 
              ctx.stroke();
            } else { // point on an element, draw a frame
              var r = getOffsetRectangle(canvas, selection.geometry()._elements[p.index]);
              ctx.strokeRect(r.left, r.top, r.right-r.left, r.bottom-r.top);
            }
          }
        }
        if (drawCursor) { 
          ctx.strokeStyle = 'blue';
          var p = selection.cursor();
          if (p !== undefined && p.index !== null) { 
            var r = getOffsetRectangle(canvas, selection.geometry()._elements[p.index]);
            ctx.strokeRect(r.left, r.top, r.right-r.left, r.bottom-r.top);
          }
        }
        if (drawRubber) { 
          ctx.strokeStyle = 'green';
          var p1 = multiselect.anchor(selection.selectionPath());
          if (p1 !== undefined && p1.index === null) {
            var p2 = multiselect.activeEnd(selection.selectionPath());
            ctx.strokeRect(Math.min(p1.point.x, p2.point.x),
                           Math.min(p1.point.y, p2.point.y),
                           Math.abs(p1.point.x-p2.point.x),
                           Math.abs(p1.point.y-p2.point.y));
          }
        }
      }
      var canvas3 = createCanvas(selectableArea3);
      setupMouseEvents(selectableArea3, canvas3, selection3);
      setupKeyboardEvents(selectableArea3, canvas3, selection3);
    
  });
</script>

<p>
Most of the &ldquo;snake&rdquo; geometry is straightforward.
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-geometry"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">SnakeGeometry</span> = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">parent</span>, <span style="color: #BA36A5;">elements</span>) {
  <span style="color: #8b1a1a;">this</span>._parent = parent;
  <span style="color: #8b1a1a;">this</span>._elements = elements;
  <span style="color: #8b1a1a;">this</span>._k = 0;
}
SnakeGeometry.<span style="color: #8b1a1a;">prototype</span> = Object.create(multiselect.DefaultGeometry.<span style="color: #8b1a1a;">prototype</span>);

SnakeGeometry.<span style="color: #8b1a1a;">prototype</span>.extendPath = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">path</span>, <span style="color: #BA36A5;">p</span>) { path.push(p); }
</pre>
</div>

<p>
The <code>extendPath</code> method simply adds new element to the path.
Selection space coordinates are the same as the mouse coordinates,
and hence <code>m2v</code> need not be defined.
Computing the selection domain, however, requires a bit more effort.
The function iterates over all line segments defined by two adjacent points
in the selection path. For each line segment, it finds the elements that
the line segment intersects with, and adds them to the selection 
domain. This is quite a bit of work, and thus the <code>selectionDomain</code>
function implements an optimization. When it is finished
computing a selection domain, it stores the last index of the selection
path in <code>this._k</code>. If <code>selectionDomain</code> is
called from <code>shiftClick</code> (this is how it is called when rubber band
selection is going on), the call includes the previously calculated
selection domain (<code>J</code>) as the third parameter.
It then suffices to iterate the line segments in the path from index <code>_k</code> 
onwards.
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-selection-domain">  SnakeGeometry.<span style="color: #8b1a1a;">prototype</span>.selectionDomain = <span style="color: #0000FF;">function</span>(<span style="color: #BA36A5;">path</span>, <span style="color: #BA36A5;">source</span>, <span style="color: #BA36A5;">J</span>) {  
    <span style="color: #0000FF;">if</span> (J === <span style="color: #8b1a1a;">undefined</span>) J = multiselect.makeEmptyMap(); 
    <span style="color: #0000FF;">switch</span> (source) {
      <span style="color: #0000FF;">case</span> multiselect.C_SHIFT_CLICK: <span style="color: #0000FF;">break</span>;
      <span style="color: #0000FF;">case</span> multiselect.C_SET_PATH: 
      <span style="color: #0000FF;">case</span> <span style="color: #8b1a1a;">undefined</span>: 
        <span style="color: #8b1a1a;">this</span>._k = 0;
    }
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">prev</span> = <span style="color: #8b1a1a;">this</span>._k;
    <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span> = <span style="color: #8b1a1a;">this</span>._k; i &lt; path.length; ++i) {
      <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">j</span> = 0; j &lt; <span style="color: #8b1a1a;">this</span>._elements.length; ++j) {
        <span style="color: #0000FF;">if</span> (lineRectIntersect(path[i], path[prev],
                              getOffsetRectangle(<span style="color: #8b1a1a;">this</span>._parent, <span style="color: #8b1a1a;">this</span>._elements[j]))) J.set(j, <span style="color: #8b1a1a;">true</span>);
      }
      prev = i;
    }
    <span style="color: #8b1a1a;">this</span>._k = path.length - 1;

    <span style="color: #0000FF;">return</span> J;
  }
</pre>
</div>

<p>
A few more substantial helper functions are needed. 
The <code>lineRectIntersect</code> function determines if a line intersects with a rectangle,
<code>mkRectangle</code> constructs a rectangle from two points:
</p>

<div class="org-src-container">

<pre class="src src-js" id="line-rect-intersect"><span style="color: #0000FF;">function</span> <span style="color: #006699;">lineRectIntersect</span>(<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span>, <span style="color: #BA36A5;">r</span>) {
  <span style="color: #0000FF;">if</span> (!rectangleIntersect(mkRectangle(p1, p2), r)) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">false</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">if bounding boxes do not overlap, cannot intersect</span>
  <span style="color: #0000FF;">if</span> (pointEquals(p1, p2)) <span style="color: #0000FF;">return</span> pointInRectangle(p1, r);
  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = {};
  <span style="color: #0000FF;">if</span> (lineIntersect(p1, p2, { x: r.left, y: r.top }, { x: r.left, y: r.bottom }, p) === 1) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
  <span style="color: #0000FF;">if</span> (lineIntersect(p1, p2, { x: r.left, y: r.top }, { x: r.right, y: r.top }, p) === 1) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
  <span style="color: #0000FF;">if</span> (lineIntersect(p1, p2, { x: r.right, y: r.bottom }, { x: r.right, y: r.top }, p) === 1) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
  <span style="color: #0000FF;">if</span> (lineIntersect(p1, p2, { x: r.right, y: r.bottom }, { x: r.left, y: r.bottom }, p) === 1) <span style="color: #0000FF;">return</span> <span style="color: #8b1a1a;">true</span>;
  <span style="color: #0000FF;">return</span> pointInRectangle(p1, r) || pointInRectangle(p2, r);
}

<span style="color: #0000FF;">function</span> <span style="color: #006699;">mkRectangle</span>(<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span>) {
  <span style="color: #0000FF;">return</span> { 
    left: Math.min(p1.x, p2.x),
    top: Math.min(p1.y, p2.y),
    right: Math.max(p1.x, p2.x),
    bottom: Math.max(p1.y, p2.y)
  };        
}

<span style="color: #0000FF;">function</span> <span style="color: #006699;">pointEquals</span>(<span style="color: #BA36A5;">p1</span>, <span style="color: #BA36A5;">p2</span>) { <span style="color: #0000FF;">return</span> p1.x === p2.x &amp;&amp; p1.y === p2.y; }
</pre>
</div>

<p>
The <code>lineIntersect</code> function is more involved.
The code is a bit long, so we show it at the very end of this document in Section <a href="#sec-line-intersection-code">4.3</a>.
</p>





<p>
Constructing the selection state is familiar:
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-create-selection-state"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">geometry3</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">SnakeGeometry</span>(selectableArea3, selectables3);
<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">selection3</span> = <span style="color: #0000FF;">new</span> <span style="color: #6434A3;">multiselect.SelectionState</span>(geometry3, mkRefresh(selectables3, <span style="color: #008000;">'selected2'</span>), <span style="color: #8b1a1a;">true</span>);
</pre>
</div>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Draw indicators</h3>
<div class="outline-text-3" id="text-4-1">
<div class="org-src-container">

<pre class="src src-js" id="snake-draw-indicators">  geometry3.drawIndicators = <span style="color: #0000FF;">function</span> (<span style="color: #BA36A5;">selection</span>, <span style="color: #BA36A5;">canvas</span>, <span style="color: #BA36A5;">drawAnchor</span>, <span style="color: #BA36A5;">drawCursor</span>, <span style="color: #BA36A5;">drawRubber</span>) {
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">ctx</span> = canvas.getContext(<span style="color: #008000;">'2d'</span>);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    <span style="color: #0000FF;">if</span> (drawAnchor) { 
      ctx.strokeStyle = <span style="color: #008000;">'DarkRed'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = multiselect.anchor(selection.selectionPath());
      <span style="color: #0000FF;">if</span> (p !== <span style="color: #8b1a1a;">undefined</span>) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2, <span style="color: #8b1a1a;">true</span>); 
        ctx.stroke();
      }
    }
    <span style="color: #0000FF;">if</span> (drawCursor) { 
      ctx.strokeStyle = <span style="color: #008000;">'blue'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">p</span> = selection.cursor();
      <span style="color: #0000FF;">if</span> (p !== <span style="color: #8b1a1a;">undefined</span>) { 
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2, <span style="color: #8b1a1a;">true</span>); 
        ctx.stroke();
      }
    }
    <span style="color: #0000FF;">if</span> (drawRubber) { 
      ctx.strokeStyle = <span style="color: #008000;">'green'</span>;
      <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">path</span> = selection.selectionPath();
      <span style="color: #0000FF;">if</span> (path.length &gt; 0) {
        ctx.moveTo(path[0].x, path[0].y);
        <span style="color: #0000FF;">for</span> (<span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">i</span> = 1; i &lt; path.length; ++i) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();
      }
    }
  }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Setting up mouse events</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The setup code from the previous example does what we want:
</p>

<div class="org-src-container">

<pre class="src src-js" id="snake-setup-mouse-events">  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">canvas3</span> = createCanvas(selectableArea3);
  setupMouseEvents(selectableArea3, canvas3, selection3);
  setupKeyboardEvents(selectableArea3, canvas3, selection3);
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-line-intersection-code" class="outline-3">
<h3 id="sec-line-intersection-code"><a id="sec-4-3"></a><span class="section-number-3">4.3</span> Line intersection code</h3>
<div class="outline-text-3" id="text-sec-line-intersection-code">
<p>
This function is adapted from Prasad Mukesh&rsquo;s C-code <i>Intersection of Line Segments</i>, 
ACM Transaction of Graphics&rsquo; Graphics Gems II, p. 7&#x2013;9, code: p. 473&#x2013;476, <code>xlines.c</code>.
</p>

<div class="org-src-container">

<pre class="src src-js" id="line-intersect">  <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">PORTED FROM:</span>

<span style="color: #8D8D84; font-style: italic;">   * lines_intersect:  AUTHOR: Mukesh Prasad</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   This function computes whether two line segments,</span>
<span style="color: #8D8D84; font-style: italic;">   *   respectively joining the input points (x1,y1) -- (x2,y2)</span>
<span style="color: #8D8D84; font-style: italic;">   *   and the input points (x3,y3) -- (x4,y4) intersect.</span>
<span style="color: #8D8D84; font-style: italic;">   *   If the lines intersect, the output variables x, y are</span>
<span style="color: #8D8D84; font-style: italic;">   *   set to coordinates of the point of intersection.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   All values are in integers.  The returned value is rounded</span>
<span style="color: #8D8D84; font-style: italic;">   *   to the nearest integer point.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   If non-integral grid points are relevant, the function</span>
<span style="color: #8D8D84; font-style: italic;">   *   can easily be transformed by substituting floating point</span>
<span style="color: #8D8D84; font-style: italic;">   *   calculations instead of integer calculations.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   Entry</span>
<span style="color: #8D8D84; font-style: italic;">   *        x1, y1,  x2, y2   Coordinates of endpoints of one segment.</span>
<span style="color: #8D8D84; font-style: italic;">   *        x3, y3,  x4, y4   Coordinates of endpoints of other segment.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   Exit</span>
<span style="color: #8D8D84; font-style: italic;">   *        x, y              Coordinates of intersection point.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *   The value returned by the function is one of:</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *        DONT_INTERSECT    0</span>
<span style="color: #8D8D84; font-style: italic;">   *        DO_INTERSECT      1</span>
<span style="color: #8D8D84; font-style: italic;">   *        COLLINEAR         2</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   * Error conditions:</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *     Depending upon the possible ranges, and particularly on 16-bit</span>
<span style="color: #8D8D84; font-style: italic;">   *     computers, care should be taken to protect from overflow.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   *     In the following code, 'long' values have been used for this</span>
<span style="color: #8D8D84; font-style: italic;">   *     purpose, instead of 'int'.</span>
<span style="color: #8D8D84; font-style: italic;">   *</span>
<span style="color: #8D8D84; font-style: italic;">   */</span>

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">sameSigns</span>(<span style="color: #BA36A5;">a</span>, <span style="color: #BA36A5;">b</span>) { <span style="color: #0000FF;">return</span> a &gt;= 0 &amp;&amp; b &gt;= 0 || a &lt; 0 &amp;&amp; b &lt; 0; }

  <span style="color: #0000FF;">function</span> <span style="color: #006699;">lineIntersect</span>( <span style="color: #BA36A5;">p1</span>,   <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">First line segment */</span>
                          <span style="color: #BA36A5;">p2</span>,
                          <span style="color: #BA36A5;">p3</span>,   <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Second line segment */</span>
                          <span style="color: #BA36A5;">p4</span>,
                          p5    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Output value:</span>
<span style="color: #8D8D84; font-style: italic;">                                 * point of intersection */</span>
                        )
  {
    <span style="color: #0000FF;">const</span> <span style="color: #BA36A5;">DONT_INTERSECT</span> = 0;
    <span style="color: #0000FF;">const</span> <span style="color: #BA36A5;">DO_INTERSECT</span> = 1;
    <span style="color: #0000FF;">const</span> <span style="color: #BA36A5;">COLLINEAR</span> = 2;

    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">a1</span>, <span style="color: #BA36A5;">a2</span>, <span style="color: #BA36A5;">b1</span>, <span style="color: #BA36A5;">b2</span>, <span style="color: #BA36A5;">c1</span>, <span style="color: #BA36A5;">c2</span>; <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Coefficients of line eqns. */</span>
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">r1</span>, <span style="color: #BA36A5;">r2</span>, <span style="color: #BA36A5;">r3</span>, <span style="color: #BA36A5;">r4</span>;         <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">'Sign' values */</span>
    <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">denom</span>, <span style="color: #BA36A5;">offset</span>, <span style="color: #BA36A5;">num</span>;     <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Intermediate values */</span>

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Compute a1, b1, c1, where line joining points 1 and 2</span>
<span style="color: #8D8D84; font-style: italic;">     * is "a1 x  +  b1 y  +  c1  =  0".</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>

    a1 = p2.y - p1.y;
    b1 = p1.x - p2.x;
    c1 = p2.x * p1.y - p1.x * p2.y;

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Compute r3 and r4.</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>
    r3 = a1 * p3.x + b1 * p3.y + c1;
    r4 = a1 * p4.x + b1 * p4.y + c1;

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Check signs of r3 and r4.  If both point 3 and point 4 lie on</span>
<span style="color: #8D8D84; font-style: italic;">     * same side of line 1, the line segments do not intersect.</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>
    <span style="color: #0000FF;">if</span> ( r3 != 0 &amp;&amp;
         r4 != 0 &amp;&amp;
         sameSigns( r3, r4 ))
      <span style="color: #0000FF;">return</span> ( DONT_INTERSECT );

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Compute a2, b2, c2 */</span>
    a2 = p4.y - p3.y;
    b2 = p3.x - p4.x;
    c2 = p4.x * p3.y - p3.x * p4.y;

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Compute r1 and r2 */</span>
    r1 = a2 * p1.x + b2 * p1.y + c2;
    r2 = a2 * p2.x + b2 * p2.y + c2;

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Check signs of r1 and r2.  If both point 1 and point 2 lie</span>
<span style="color: #8D8D84; font-style: italic;">     * on same side of second line segment, the line segments do</span>
<span style="color: #8D8D84; font-style: italic;">     * not intersect.</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>
    <span style="color: #0000FF;">if</span> ( r1 !== 0 &amp;&amp;
         r2 !== 0 &amp;&amp;
         sameSigns( r1, r2 ))
      <span style="color: #0000FF;">return</span> ( DONT_INTERSECT );

    <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Line segments intersect: compute intersection point. </span>
<span style="color: #8D8D84; font-style: italic;">     */</span>

    denom = a1 * b2 - a2 * b1;
    <span style="color: #0000FF;">if</span> ( denom === 0 )
      <span style="color: #0000FF;">return</span> ( COLLINEAR );
    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">offset = denom &lt; 0 ? - denom / 2 : denom / 2;</span>

    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">/* The denom/2 is to get rounding instead of truncating.  It</span>
    <span style="color: #8D8D84;">//  </span><span style="color: #8D8D84; font-style: italic;">* is added or subtracted to the numerator, depending upon the</span>
    <span style="color: #8D8D84;">//  </span><span style="color: #8D8D84; font-style: italic;">* sign of the numerator.</span>
    <span style="color: #8D8D84;">//  </span><span style="color: #8D8D84; font-style: italic;">*/</span>

    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">num = b1 * c2 - b2 * c1;</span>
    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">p5.x = ( num &lt; 0 ? num - offset : num + offset ) / denom;</span>

    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">num = a2 * c1 - a1 * c2;</span>
    <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">p5.y = ( num &lt; 0 ? num - offset : num + offset ) / denom;</span>

    <span style="color: #0000FF;">return</span> DO_INTERSECT;
  }
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
Command-click in Macs correspond to control-click in Windows. Other
computers or operating systems might use still different modifier keys.
</p></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<code>Map</code> is part of the draft EcmaScript 6 standard, see
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map</a>.
It is already supported by all major browsers.
</p></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
Only the anchor and active end matter in the first example too.
There we rely on the default <code>extendPath</code>, which also discards the
intermediate points.
</p></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
Perhaps ``lasso&rsquo;&rsquo; selection where the user draws a path around
the elements to be selected is a more common freehand selection
mechanism. Identifying the elements that intersect with an arbitrary
polygon is, however, quite a bit more complex than identifying
elements that intersect with a path.  For this tutorial, we choose to
implement the less complex selection mechanism. For the geometrical
calculations of lasso selection, a computational geometry library,
such as <code>Raphael.js</code>, would be useful.
</p></div>


</div>
</div></div>
</body>
</html>
